---
name: opencode-acp
description: 通过 ACP 协议与 OpenCode 协作，进行代码修改、重构以及功能实现。
metadata:
  {
    "openclaw": { "emoji": "🔧", "requires": { "anyBins": ["opencode"] } },
  }
---
# OpenCode ACP协作

通过ACP（Agent Client Protocol）使用OpenCode进行代码修改、重构和功能实现。

## 快速入门

### 自动化工作流程（推荐）

使用提供的Python脚本来实现自动化OpenCode协作：

- 首次运行时，该技能会在当前目录中自动创建一个`.venv`（Python 3.9+）环境，并在该环境中重新运行。
- 如果当前解释器的版本低于3.9，系统会自动检测并使用本地可用的Python 3.9+可执行文件（如`python3.12`/`python3.11`/`python3.10`/`python3.9`/`python`；在Windows系统中也会使用`py -3.x`）。

**功能说明：**
1. 启动OpenCode ACP服务器
2. 初始化ACP连接
3. 创建会话
4. 发送任务
5. 监控进度并显示输出
6. 任务完成后停止OpenCode

**输出内容：**
- 实时进度更新
- 工具调用情况与状态
- 代理消息
- 任务完成状态

### 手动工作流程（高级）

如需更精细的控制，可以使用JSON-RPC手动消息进行交互：

---

## 操作模式：计划 → 执行 → 验证

### 第1步：分析需求

**作为规划者的你的任务：**
- 理解用户需求
- 识别技术限制
- 评估影响和风险

**输出内容：**
- 明确、具体的需求
- 技术限制
- 风险评估

### 第2步：制定计划

**作为规划者的你的任务：**
- 将任务分解为可执行的步骤
- 定义验收标准
- 提供实施指导

**格式示例：**

---

### 第3步：使用OpenCode执行任务

**启动OpenCode ACP服务器：**
---

**初始化连接：**
---

**创建会话：**
---

**发送任务：**
---

### 第4步：监控进度

**定期检查更新：**
---

**关键更新类型：**
- `agent_thought_chunk` - OpenCode的思考过程
- `tool_call` - 工具调用（搜索、分析、编辑）
- `plan` - 任务计划更新
- `stopReason` - 任务完成信号

**停止条件：**
- `stopReason: "end_turn"` - 任务正常完成
- `stopReason: "cancelled"` - 任务被取消
- 超时（建议设置：5-10分钟）

### 第5步：验证结果

**验证清单：**
- ✅ 代码更改符合需求
- ✅ 验收标准得到满足
- ✅ 代码风格一致
- ✅ 测试通过
- ✅ 无回归问题

**验证方法：**
1. 查看OpenCode的变更总结
2. 运行相关测试
3. 手动验证关键功能
4. 进行代码质量检查

### 第6步：清理

**停止OpenCode：**
---

**记录结果：**
- 更新`memory/YYYY-MM-DD.md`文件
- 记录成功/失败的原因
- 记录经验教训

## ⚠️ 首次使用项目时的设置

如果这是OpenCode首次参与项目，请先初始化知识库：

1. **启动OpenCode TUI**（非ACP模式）：
---

2. **运行初始化脚本：**
---

3. **等待完成：**
   - OpenCode会创建分层的AGENTS.md知识库
   - 分析项目结构和代码
   - 构建项目上下文

4. **退出后以ACP模式重新启动：**
   - 初始化完成后，退出TUI
   - 使用`opencode acp`重新启动以进行协作

**为什么要进行深度初始化？**
- 有助于OpenCode理解项目结构
- 构建代码知识图谱
- 提高执行效率和准确性
- 减少不必要的探索和试错

## OpenCode配置

**配置文件位置：`/root/.opencode/opencode.json`

**推荐模式：** `sisyphus`（AI编排器）

## ACP协议详情

**协议版本：** 1

**传输格式：** JSON-RPC 2.0

**消息分隔符：** 新行（\n）

**通信方式：** 标准输入/标准输出（stdin/stdout）

## 可用的OpenCode模式**

- **sisyphus**（推荐）：强大的AI编排器，擅长规划和任务分配
- **hephaestus**：自主的深度工作代理，能够完成端到端的任务
- **prometheus**：仅用于规划的任务代理
- **atlas**：任务编排器

## 最佳实践

### 1. 明确需求

**正确做法：**
---

**错误做法：**
---

### 2. 制定验收标准

**良好的验收标准：**
- 具体、可衡量、可验证
- 包括正面和负面的测试用例
- 考虑边缘情况

**示例：**
- ✅ 运行`command --version`时显示正确的版本信息
- ✅ 运行`command -v`时显示相同的结果
- ✅ 显示的版本与`package.json`一致
- ✅ 程序的退出代码为0
- ✅ 不影响其他命令的执行

### 3. 进度监控

**关键指标：**
- 任务细分数量（通常为3-7个子任务）
- 后台代理数量（通常为2-4个）
- 工具调用次数（搜索、分析、编辑）
- 执行时间（通常为2-10分钟）

**警告信号：**
- 长时间无响应（超过2分钟）
- 反复出现错误信息
- 工具调用失败
- 超时

### 4. 错误处理**

**常见错误：**
1. **GLIBC版本问题**：某些工具（如`ast_grep`）可能不兼容
   - 解决方案：OpenCode会自动切换到其他工具
2. **代理未找到**：例如，“librarian”代理不可用
   - 解决方案：OpenCode会使用其他代理
3. **超时**：任务执行时间过长
   - 解决方案：将任务拆分为更小的部分或增加超时时间

## 协作原则

### 规划者的职责

1. **明确需求**：
   - 具体、可衡量、可验证
   - 提供上下文和限制条件
   - 提供示例和参考资料

2. **合理的计划**：
   - 将任务分解为小步骤
   - 考虑技术可行性
   - 估算工作量

3. **有效的验证**：
   - 明确的验收标准
   - 可执行的验证方法
   - 及时的反馈

### 执行者的特点（OpenCode）

1. **自动规划**：
   - 将需求分解为子任务
   - 自动选择工具和方法
   - 并行执行多个任务

2. **智能执行**：
   - 使用`sisyphus`模式（AI编排器）
   - 启动后台代理进行探索
   - 自动搜索和分析代码

## 实际案例

### 示例：为QMD添加`--version`命令

**需求：** 添加`--version`命令行选项

**规划者的工作：**
1. 分析需求：需要读取`package.json`中的版本信息并显示项目详情
2. 制定计划：
   - 定位CLI参数解析逻辑
   - 添加版本标志的处理逻辑
   - 实现版本信息的输出
   - 编写测试用例
3. 设定验收标准：
   - `bun src/qmd.ts --version`能显示正确的版本信息
   `-v`别名也能正常使用
   - 显示的版本与`package.json`一致
   - 不影响现有功能

**OpenCode的工作流程：**
1. 自动将任务分解为5个子任务
2. 同时启动3个代理进行任务执行
3. 搜索代码结构（解析CLI参数、获取版本信息、运行测试）
4. 实施代码更改
5. 运行测试进行验证

**结果：**
- ✅ 协作流程成功验证
- ✅ OpenCode自动完成规划和执行
- ✅ 并行处理提高了效率
- ✅ 提供实时进度反馈

## 常见问题

### Q1：首次使用项目时该怎么办？

**回答：**
首次使用项目时，必须先初始化知识库：

1. 启动OpenCode TUI：
---

2. 运行初始化脚本：
---

3. 完成初始化后，以ACP模式继续协作

**目的：**
- 创建分层的AGENTS.md知识库
- 分析项目结构和依赖关系
- 构建代码上下文，提高执行效率

### Q2：如何选择OpenCode模式？

**回答：**
- **sisyphus**（默认模式）：适用于大多数任务，具备自动规划和并行执行的能力
- **hephaestus**：适用于需要深入分析的复杂任务
- **prometheus**：仅用于规划，不涉及任务执行

### Q3：如何处理OpenCode执行失败？

**回答：**
1. 检查错误信息和日志
2. 分析失败原因（是需求不明确还是技术限制？）
3. 调整计划或需求
4. 重新启动OpenCode
5. 如果多次失败，可以考虑手动完成任务

### Q4：如何提高协作效率？

**回答：**
1. **明确需求**：减少OpenCode的猜测和试错
2. **合理分解任务**：将大任务拆分为小任务
3. **并行执行**：利用OpenCode的并行处理能力
4. **及时反馈**：密切监控进度并适时调整

### Q5：其他代理如何使用这个工作流程？**

- **Butler Agent**：在制定长期计划时，可以将代码修改任务委托给OpenCode
- **Challenger Agent**：在发现优化机会时，可以使用OpenCode快速实现功能
- **Main Agent**：在接收用户需求时，可以协调OpenCode的执行

所有代理都遵循相同的工作流程：分析需求 → 制定计划 → 启动OpenCode → 监控进度 → 验证结果。

## 规则

1. **始终使用`pty:true`**：OpenCode需要终端环境
2. **首次使用项目时必须初始化**：在使用前运行`/init-deep`命令
3. **明确需求**：需求要具体、可衡量、可验证
4. **监控进度**：定期检查日志，不要盲目等待
5. **验证结果**：始终检查验收标准
6. **记录经验**：记录成功和失败的情况
7. **耐心等待**：不要过早结束会话
8. **使用`process:log`命令**：在不干扰运行的情况下监控进度

## 进度更新

在后台启动OpenCode时，需及时通知用户：

- 启动时发送一条简短的消息，说明正在执行的操作和位置
- 仅在有变化时更新信息：
  - 里程碑完成（例如构建完成、测试通过）
  - OpenCode需要用户输入
  - 发生错误或需要用户操作
  - 任务完成（包括具体变更内容和位置）
- 如果需要结束会话，立即说明原因

这样可以避免出现“代理在回复前失败”导致的混淆。

## 完成任务后的自动通知

对于耗时较长的任务，添加唤醒触发机制：

---

**示例：**

---

**这样可以在几秒钟内收到通知。**

## 版本历史

- **v1.0**（2026-02-16）：初始版本
  - OpenCode 1.2.1
  - ACP协议版本1
  - 使用`sisyphus`模式
  - 测试项目：openclaw-qmd

---

**最后更新时间：** 2026-02-16  
**维护者：** Claw 🐾  
**状态：** ✅ 已验证