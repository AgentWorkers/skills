---
name: GraphQL
slug: graphql
version: 1.0.1
description: 设计具有良好性能、安全性和错误处理能力的 GraphQL 模式（schemas）和解析器（resolvers）。
metadata: {"clawdbot":{"emoji":"◈","os":["linux","darwin","win32"]}}
---

## 快速参考

| 主题 | 文件      |
|-------|---------|
| 模式设计模式 | `schema.md`   |
| 安全性与限制   | `security.md`  |
| 性能优化   | `performance.md` |
| 客户端模式   | `client.md`   |

## N+1 问题（严重问题）

- 每个解析器都是独立运行的——对于 100 条帖子，每个解析器都需要获取用户信息，因此会执行 100 次查询。
- 需要使用 DataLoader：在单个时间周期内批量处理请求——100 条帖子对应 1 次用户查询。
- 每次请求都创建一个新的 DataLoader 实例：这样可以防止请求之间的缓存冲突。
- 即使使用了 DataLoader，也需要注意嵌套的 N+1 问题（例如：帖子 → 评论 → 作者的关联）。

## 模式设计

- 字段默认为可空值——需要明确指定哪些字段必须为非空值：`name: String!`
- 输入类型与输出类型分开：使用 `CreateUserInput` 和 `User` 类型，以便进行不同的验证。
- 分页相关的字段：`users(first: 10, after: "cursor")` 会返回 `edges` 和 `pageInfo`。
- 应尽量避免使用深度嵌套的类型；超过 5 层的嵌套结构会增加解析器的复杂性。

## 分页

- 基于游标的分页方式（Relay 风格）：使用 `first/after` 和 `last/before` 参数。
- 基于偏移量的分页方式：使用 `limit/offset` 参数；这种方式更简单，但在并发写入时可能会导致数据重复或遗漏。
- 返回 `pageInfo` 对象，其中包含 `hasNextPage` 和 `endCursor`：客户端可以根据这些信息判断是否需要继续分页。
- 对于大型数据集，计算 `totalCount` 的操作可能会非常耗时——可以选择不返回该值或进行估算。

## 安全隐患

- 限制查询的深度：防止出现如 `{ user { friends { friends { friends... } } }` 这样的嵌套查询。
- 对查询的复杂性进行评分：统计涉及的字段数量，并根据字段数量乘以列表的长度来计算查询的复杂度；超过阈值时拒绝执行该查询。
- 在生产环境中禁用对象的“自 introspection”功能；或者通过身份验证来保护数据安全（因为模式本身可能成为攻击面）。
- 为每个查询设置超时限制：恶意查询即使不涉及深度嵌套，也可能导致系统响应缓慢。
- 根据查询的复杂性设置速率限制，而不仅仅是基于请求的数量；一个复杂的查询可能等价于多个简单的查询。

## 错误处理

- 部分请求成功也是正常的：查询结果中应同时包含数据和错误信息；需要同时检查两者。
- 错误信息应包含错误的详细路径：例如 `"path": ["user", "posts", 0]"。
- 使用错误代码进行错误分类：`"extensions": {"code": "FORBIDDEN"}`；不要直接解析错误消息。
- 如果解析器返回 `null`，则直接抛出错误；如果父对象不为空，则错误信息会向上层传递。

## 解析器模式

- 返回包含 ID 的对象，让子解析器负责获取详细信息——这样可以避免在顶层进行不必要的数据获取。
- 使用 `__resolveType` 来区分不同的数据类型（如联合类型或接口类型）。
- 为身份验证、数据加载器、数据库连接等提供统一的上下文信息，并将这些信息传递给解析器链。
- 在解析器中实现字段级别的身份验证机制：根据每个字段的权限进行检查，而不仅仅是基于整个查询。

## 数据修改

- 返回修改后的对象：客户端可以直接更新缓存，而无需重新请求数据。
- 在将数据写入数据库之前进行输入验证；返回易于理解的错误信息，而不是直接显示数据库的约束错误。
- 对于关键的数据修改操作，需要保证操作的幂等性（即多次执行相同操作应得到相同的结果）；可以接受客户端生成的 ID 或幂等性键。
- 通常每个操作只进行一次数据修改；虽然批量修改是可行的，但会增加错误处理的复杂性。

## 性能优化

- 对已执行的查询进行哈希处理，建立查询映射关系：这样可以减少传输的数据量，防止不必要的请求。
- 对于处理速度较慢的字段，使用 `@defer` 标注：先返回快速处理的字段，延迟返回慢速处理的字段（如果支持的话）。
- 根据组件的数据需求进行数据布局优化，减少不必要的数据获取。
- 在生产环境中，只允许注册过的查询被执行；这样可以防止恶意攻击。

## 订阅功能

- 基于 WebSocket 的订阅机制：使用 `graphql-ws` 协议；与 HTTP 请求分离。
- 需要支持发布/订阅（pub/sub）模式：可以使用 Redis 或类似的技术来实现多服务器间的数据广播。
- 在订阅层进行数据过滤：不要推送所有数据，而是在客户端进行过滤。
- 在客户端断开连接时取消订阅：及时释放资源，并进行连接跟踪。

## 客户端端

- 使用 Apollo 或 Relay 等工具实现缓存机制：通过 ID 对数据进行去重；更新操作会自动传播到客户端。
- 采用乐观的 UI 设计：预测数据修改的结果；如果服务器返回的结果与预期不同，可以回滚操作。
- 根据具体情况制定错误处理策略：可以选择忽略错误、返回部分数据或将其视为失败。
- 重用数据片段：定义一次后可以在多个查询中使用相同的片段数据；这样可以保持数据的一致性。

## 常见错误

- 不使用 DataLoader：会导致 N+1 问题，从而严重影响性能；一个简单的查询可能会变成数百次请求。
- 暴露内部错误：堆栈跟踪信息可能会泄露实现细节。
- 不设置查询限制：攻击者可以构造复杂的查询来消耗系统资源；单个请求也可能导致拒绝服务（DoS）。
- 在解析器中过度获取数据：即使只需要获取 ID 和名称，也可能获取到整个对象。
- 将 GraphQL 当作 REST 请求来使用：GraphQL 实际上是一个图数据模型；设计时应该考虑数据的遍历方式，而不仅仅是单个资源。