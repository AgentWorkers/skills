---
name: C
slug: c
version: 1.0.1
description: 编写安全的C语言程序，避免内存损坏、缓冲区溢出以及未定义行为导致的错误。
metadata: {"clawdbot":{"emoji":"⚙️","requires":{"bins":["gcc","clang"]},"os":["linux","darwin","win32"]}}
---

## 快速参考

| 主题 | 文件 |
|-------|------|
| `malloc/free`、内存泄漏、双重释放 | `memory.md` |
| `NULL`指针、悬空指针、指针运算 | `pointers.md` |
| `NULL`终止符、缓冲区溢出 | `strings.md` |
| 整数溢出（有符号/无符号类型） | `types.md` |
| 宏陷阱、包含文件保护机制 | `preprocessor.md` |
| 常见未定义行为 | `undefined.md` |

## 重要规则

- `malloc` 函数返回 `void*` 类型；在 C++ 中需要强制类型转换，在 C 语言中可以省略类型转换，但必须检查返回值是否为 `NULL`。
- 使用 `free(ptr); ptr = NULL;` 时，释放内存后指针必须被设置为 `NULL`，以防止双重释放（即多次释放同一块内存）。
- 在函数中使用 `sizeof(array)` 时会得到指针的大小，而非数组的实际大小；数组的长度应单独传递。
- 例如：`char str[5] = "hello";` 这种写法没有为字符串预留 `NULL` 终止符的空间，可能导致未定义行为（UB: Undefined Behavior）。
- `strcpy` 函数不检查字符串边界；应使用 `strncpy` 并手动添加 `NULL` 终止符。
- 有符号整数溢出会导致未定义行为（UB）；编译器可能会优化这种情况，但仍然存在风险。
- `i++ + i++` 这种写法会导致未定义行为，因为两次对同一个变量进行自增操作之间没有明确的执行顺序。
- 将指针返回给局部变量会导致悬空指针；使用这样的指针会导致未定义行为（UB）。
- 定义宏 `SQUARE(x) x*x` 时，`SQUARE(1+2)` 的计算结果为 `1+2*1+2`，即 5 而不是 9。
- 当需要复制重叠的数据区域时，应使用 `memmove` 而不是 `memcpy`。
- 未初始化的变量可能包含随机数据；使用这些变量会导致未定义行为（UB）。
- 超出数组范围的访问会导致未定义行为（UB）：程序可能无声地损坏数据或崩溃。