---
name: React
slug: react
version: 1.0.3
description: 使用 Hooks、状态管理、性能优化以及组件模式来构建 React 应用程序。
---

## 适用场景

当用户需要具备 React 相关的专业知识时（从组件设计到生产环境的最佳实践），代理（Agent）会处理钩子（hooks）、状态管理（state management）、渲染优化（render optimization）以及数据获取（data fetching）等任务。

## 快速参考

| 主题 | 文件 |
|-------|------|
| 钩子模式 | `hooks.md` |
| 状态管理 | `state.md` |
| 性能优化 | `performance.md` |
| 组件模式 | `patterns.md` |

## 常见错误

- 当 `count` 为 0 时，表达式 `{count && <Component />` 会渲染出 “0” — 对于数值条件，应始终使用 `{count > 0 && <Component />`  
- 绝不要直接修改状态（例如：`array.push()` 后再调用 `setState(array)` — React 无法检测到这种变化；应使用 `setState([...array, item])` 进行状态更新  
- 在渲染过程中生成的键（如 `key={Math.random()}`）会导致组件在每次渲染时都被重新创建 — 应在数据生成时生成稳定的键值对  
- 未初始化的受控输入（使用 `useState()` 且未设置默认值）会导致组件状态在受控与非受控状态之间切换 — 必须使用空字符串或适当的默认值进行初始化  

## 钩子使用中的陷阱

- `useEffect` 回调函数不能直接声明为异步函数 — 应在 `useEffect` 内部定义异步函数后再调用它  
- 如果未正确处理清理操作（例如：取消订阅、定时器或事件监听器），可能会导致内存泄漏 — 必须为这些操作返回相应的清理函数  
- 如果依赖项数组中包含对象或数组，每次渲染时都会触发重新计算（因为引用会发生变化） — 可使用 `useMemo` 对依赖项进行缓存  
- 如果 `useState` 的设置函数返回相同的引用，将不会触发重新渲染 — 对于对象或数组类型的依赖项，应始终创建新的引用  

## 性能优化

- 对于顺序执行的异步请求，应使用 `Promise.all([fetchA(), fetchB()])` 来并行处理它们  
- 使用 `import { X } from '@/components'` 进行批量导入会导致整个模块被加载 — 应使用直接路径导入（direct path imports）以实现代码的按需加载（tree-shaking）  
- 如果渲染过程中的计算操作较为复杂，每次渲染都会重新计算结果 — 应使用 `useMemo` 并指定正确的依赖项进行缓存  
- 对于非紧急的 UI 更新（如过滤、排序大量列表），可以使用 `useTransition` — 这可以在后台进行复杂操作的同时保持用户的输入响应性  
- 对于不需要触发重新渲染的值（如计时器、之前的状态值、DOM 测量结果），应使用 `useRef` 而不是 `useState`  

## 状态架构

- 尽可能将状态存储在需要使用它的地方附近 — 如果状态存储得过高，可能会导致整个子树不必要的重新渲染  
- 应从现有状态中推导出新值，而不是通过 `useEffect` 来获取状态 — 计算得到的值不需要单独的状态存储  
- 当多个状态更新同时发生时，应使用 `useReducer` 来统一处理这些更新 — 这可以避免因多次调用 `useState` 而导致的状态组合问题  
- URL 的搜索参数也应被视为状态的一部分 — 可以利用它们来实现过滤、排序或分页功能，以便用户能够分享和书签保存结果  

## 表单（React 19 及以上版本）

- 对于状态更新的操作，建议优先使用 `useAction` 而不是 `useEffect` — 因为 `useAction` 可以更好地处理待处理的操作、错误情况以及乐观更新（optimistic updates）  
- 使用 `useActionState` 来管理表单提交的状态 — 可以避免手动处理加载和错误状态  
- 使用 `useOptimistic` 可以在服务器确认之前立即更新 UI — 出现错误时可以自动恢复到之前的状态  

## 数据获取中的陷阱

- 在 `useEffect` 中获取数据时，如果没有使用错误处理机制（例如：abort controller），当组件重新挂载或依赖项发生变化时，可能会导致数据获取失败  
- 如果从自定义钩子中返回的对象没有被缓存，即使数据没有变化，调用这些钩子时也会导致组件重新渲染  
- 在需要对列表进行排序、过滤或插入操作时，如果使用索引作为键值对，可能会导致组件状态错误地应用于错误的元素上，从而引发隐藏的bug