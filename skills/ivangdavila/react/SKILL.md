---
name: React
slug: react
version: 1.0.2
description: 使用 Hooks、状态管理、性能优化以及组件模式来构建 React 应用程序。
---

## 使用场景

当用户需要具备 React 相关的专业知识时（从组件设计到生产环境下的最佳实践），代理（Agent）会处理钩子（hooks）、状态管理（state management）、渲染优化（render optimization）以及数据获取（data fetching）等任务。

## 快速参考

| 主题 | 文件名 |
|-------|------|
| 钩子模式 | `hooks.md` |
| 状态管理 | `state.md` |
| 性能优化 | `performance.md` |
| 组件模式 | `patterns.md` |

## 常见错误

- 当 `count` 为 0 时，表达式 `{count && <Component />` 会渲染出 “0” — 对于数值条件，应始终使用 `{count > 0 && <Component />`  
- 绝不要直接修改状态（例如：`array.push()` 后再调用 `setState(array)` — React 无法检测到这种变化。应使用 `setState([...array, item])` 进行状态更新。  
- 在渲染过程中生成的键（如 `key={Math.random()}`）会导致组件在每次渲染时都被重新创建 — 应在数据生成时生成稳定的键值对。  
- 未初始化的受控输入（使用 `useState()` 且未设置默认值）会导致组件状态变得不可预测 — 应始终使用空字符串或适当的默认值进行初始化。  

## 使用钩子时的陷阱

- `useEffect` 回调函数不能直接声明为异步函数 — 应在 `useEffect` 内部定义异步函数后再调用它。  
- 如果忘记在副作用（effects）中添加清理代码，可能会导致内存泄漏 — 对于订阅、定时器或事件监听器，必须返回相应的清理函数。  
- 如果依赖项数组中包含对象或数组，每次渲染时都会触发重新计算（因为依赖项的引用会改变） — 可使用 `useMemo` 对这些依赖项进行缓存。  
- 如果 `useState` 的设置函数使用相同的引用，可能会导致组件不会重新渲染 — 对于对象或数组类型的依赖项，应始终创建新的引用。  

## 性能优化

- 对于顺序执行的异步请求，应使用 `Promise.all([fetchA(), fetchB()])` 来并行处理它们。  
- 使用 `import { X } from '@/components'` 会导入整个模块 — 应使用直接路径导入（direct path imports）以实现代码的按需加载（tree-shaking）。  
- 如果渲染过程中有计算量较大的操作，会导致每次渲染时都重新计算 — 应使用 `useMemo` 并指定正确的依赖项进行缓存。  
- 对于非紧急的 UI 更新（例如过滤或排序大量数据），可以使用 `useTransition` — 这可以在后台进行复杂操作的同时保持用户的界面响应性。  
- 对于不需要触发重新渲染的值（如计时器、之前的状态值或 DOM 测量结果），应使用 `useRef` 而不是 `useState`。  

## 状态架构

- 尽可能将状态存储在需要使用它的地方附近 — 如果状态存储得过高，可能会导致整个子树不必要的重新渲染。  
- 应从现有状态中派生新的值，而不是通过 `useEffect` 来获取状态 — 计算得到的值通常不需要单独的状态存储。  
- 当多个状态需要同时更新时，应使用 `useReducer` — 这可以避免因多次调用 `useState` 而导致的状态组合问题。  
- URL 的搜索参数也应视为状态的一部分 — 可以利用它们来实现过滤、排序或分页功能，方便用户分享和书签保存。  

## 表单（React 19 及以上版本）

- 对于状态更新的操作，建议优先使用 `useAction` 而不是 `useEffect` — `useAction` 可以更好地处理待处理的操作、错误情况以及乐观更新（optimistic updates）。  
- 使用 `useActionState` 来管理表单提交的状态 — 这可以替代手动管理加载和错误状态的方式。  
- 使用 `useOptimistic` 可以在服务器确认结果之前立即更新 UI — 出现错误时可以自动恢复之前的状态。  

## 数据获取时的陷阱

- 在 `useEffect` 中获取数据时，如果没有设置异常处理机制（abort controller），可能会导致组件在重新挂载或依赖项快速变化时出现竞态条件（race conditions）。  
- 如果从自定义钩子中返回的对象没有被缓存，即使数据没有变化，使用这些对象的组件也会重新渲染。  
- 在需要对列表进行排序、过滤或插入操作时，如果使用索引作为键值对，可能会导致组件状态错误地绑定到错误的元素上。