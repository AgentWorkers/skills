---
name: TypeScript
slug: typescript
version: 1.0.2
description: 使用类型安全的 TypeScript 编程，遵循适当的类型推断规则和严格模式（strict mode）的最佳实践。
---

## 适用场景

当用户需要掌握TypeScript的相关知识时（从基础类型定义到高级泛型），该工具能够协助处理类型推断、类型缩小（type narrowing）、判别联合类型（discriminated unions）以及严格模式（strict mode）等相关问题。

## 快速参考

| 主题 | 对应文件 |
|-------|------|
| 泛型模式 | `generics.md` |
| 实用类型 | `utility-types.md` |
| 声明文件 | `declarations.md` |
| 从JavaScript迁移 | `migration.md` |

## 建议避免使用`any`

- `unknown`类型会强制你在使用前明确指定类型；而`any`会默默地破坏类型安全性。
- 对于API返回值，应为其指定具体类型，或使用`unknown`，绝不要使用`any`。
- 当你不知道变量的类型时，应使用`unknown`，而不是`any`。

## 类型推断失败的情况

- `filter(Boolean)`方法无法正确缩小类型范围——应使用`.filter((x): x is T => Boolean(x))`来明确指定类型。
- `Object.keys(obj)`返回的是`string[]`，而不是`keyof typeof obj`——这是有意为之的，因为对象可能包含额外的键。
- `Array.isArray()`方法会将类型缩小为`any[]`——可能需要额外检查元素的具体类型。
- `in`运算符只有在属性存在于联合类型的某个特定分支时才能正确缩小类型范围。

## 字面量类型的注意事项

- `let x = "hello";`这样的代码会将变量类型定义为`string`——应使用`const`或`as const`来明确指定类型。
- 对于对象属性，其类型可能会被“放宽”（即可以接受多种类型）——例如`{ status: "ok" }`，应使用`as const`或类型注解来明确类型。
- 函数的返回类型也可能被“放宽”——对于明确的返回值类型，应进行显式注解。

## 类型推断的局限性

- 在某些数组方法中，回调函数的类型信息可能无法被正确推断——在这种情况下，需要手动为参数添加类型注解。
- 泛型函数需要通过实际使用来推断其类型——`fn<T>()`无法自动推断类型，需要手动传递值或添加类型注解。
- 嵌套泛型通常难以正确推断类型——建议将复杂类型拆分为多个简单的部分并分别进行类型注解。

## 判别联合类型（Discriminated Unions）

- 为每个联合类型变体添加`type`或`kind`字段，以便进行全面的类型检查。
- 使用`default: const _never: never = x`来确保所有情况都能被正确处理——如果遗漏了某个情况，编译器会报错。
- 不要将判别联合类型与可选属性混合使用——否则会导致类型推断失败。

## `satisfies`与类型注解的区别

- `const x: Type = val`会将变量的类型“放宽”为`Type`——这样会丢失原始的类型信息。
- `const x = val satisfies Type`会保留变量的原始类型，并检查其与`Type`的兼容性——这种写法更适合用于配置对象。

## 严格的空值处理

- 可选链操作符`?.`返回的是`undefined`，而不是`null`——这对于期望接收`null`值的API来说非常重要。
- `??`操作符仅能捕获`null`或`undefined`；而`||`操作符可以捕获所有假值（包括`0`和`""`）。
- 非空值检查（`!`）应作为最后的手段使用——优先考虑使用类型缩小或提前返回`null`。

## 模块边界处理

- 对于仅用于导入类型的模块，应使用`import type`语句——这样类型信息会在运行时被剥离，避免打包工具（如Webpack）产生问题。
- 在重新导出类型时，应使用`export type { X }`语句——以防止意外引入不必要的依赖。
- 使用`.d.ts`文件对模块进行类型增强时，需要提供准确的模块路径，并使用`declare module`语句。