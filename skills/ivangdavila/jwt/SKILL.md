---
name: JWT
description: 实现安全的 JWT（JSON Web Tokens）认证机制，包括适当的验证流程和令牌管理。
metadata: {"clawdbot":{"emoji":"🔐","os":["linux","darwin","win32"]}}
---

## 安全基础

- JSON Web Tokens (JWTs) 是经过签名处理的，而非加密的；任何人都可以解码并读取其中的数据；切勿在其中存储敏感信息。
- 在信任 JWT 中的声明之前，务必验证其签名；未经验证的解码数据对身份验证毫无用处。
- **“alg: none”攻击**：应拒绝使用 “alg: none” 算法的 JWT——某些库会接受未经签名的 JWT。
- 使用强密码：HS256 算法需要至少 256 位的密钥；过短的密钥容易被暴力破解。

## 算法选择

- **HS256 (HMAC)**：对称算法，使用相同的密钥进行签名和验证——适用于单一服务。
- **RS256 (RSA)**：非对称算法，使用私钥签名、公钥验证——适用于分布式系统。
- **ES256 (ECDSA)**：签名长度比 RSA 更短，安全性相同——在空间受限的情况下更受欢迎。
- **切勿让 JWT 决定使用哪种算法**：应在服务器端根据预期的算法进行验证。

## 必需的声明字段

- `exp`（过期时间）：必须设置并验证；没有过期时间的 JWT 会永久有效。
- `iat`（发行时间）：表示 JWT 的创建时间——有助于制定失效策略。
- `nbf`（“not before”）：指定 JWT 在此时间之前无效——适用于需要控制访问时间的场景。
- 在验证时间声明时，允许存在 30-60 秒的时间偏差。

## 目标受众与发行者

- `iss`（发行者）：创建 JWT 的实体——通过验证 `iss` 可以防止跨服务之间的令牌盗用。
- `aud`（受众）：JWT 的预期接收者——API 应拒绝发给其他受众的 JWT。
- `sub`（主体）：JWT 代表的用户或实体——通常为用户的 ID。
- **令牌混淆攻击**：如果不对 `aud` 和 `iss` 进行验证，一个服务的 JWT 可能在另一个服务上被误用。

## 令牌生命周期

- **访问令牌**：生命周期较短（5-15 分钟），即使被窃取也能将损失降到最低。
- **刷新令牌**：生命周期较长，存储方式需安全，仅用于获取新的访问令牌。
- **令牌轮换**：每次使用时都应生成新的刷新令牌，并使旧令牌失效。
- **令牌撤销**：由于 JWT 是无状态的，因此撤销较为困难；可以采用设置较短过期时间并结合刷新机制，或使用黑名单来实现。

## 存储方式

- **httpOnly` cookie**：可防止 XSS 攻击，但需要额外的 CSRF 防护措施。
- **localStorage**：容易受到 XSS 攻击，但对于单页应用程序（SPA）来说使用更简单。
- **仅存储在内存中**：安全性最高，但页面刷新时会丢失数据。
- **切勿将 JWT 存储在 URL 参数中**：否则它们会出现在日志、浏览历史记录或引用头中。

## 验证流程

- 使用正确的算法验证签名（不要依赖请求头中的 `alg` 值）。
- 确保 `exp` 值在未来有效（允许存在时间偏差）。
- 检查 `iat` 值是否合理（可选）。
- 验证 `iss` 是否与预期的发行者匹配。
- 如果存在 `nbf` 字段，也需要进行验证。

## 常见错误

- 在 JWT 的有效载荷中存储敏感数据——这些数据只是经过 Base64 编码，并未加密。
- 使用过大的有效载荷——JWT 的头部大小有限制（例如，许多服务器将头部大小限制在 8KB 内）。
- 不设置过期时间——会导致令牌永久有效，从而带来安全风险。
- 在不同环境中使用相同的密钥——开发环境中的令牌可能无法在生产环境中正常使用。
- 记录 JWT 的相关信息——这些信息属于敏感数据，应像处理密码一样加以保护。

## 密钥管理

- 使用 `kid`（密钥 ID）字段来标识生成 JWT 的密钥。
- 使用 **JWKS (JSON Web Key Set)** 服务来分发公钥。
- 在过渡期间，新旧密钥可以同时使用。
- 密钥轮换后，旧令牌仍会在其过期前有效——请做好相应的计划。

## 实现方式

- 使用成熟的库来实现 JWT 的解析和生成功能，切勿自行编写相关代码。
- 可用的库包括：`jsonwebtoken`（Node.js）、`PyJWT`（Python）、`java-jwt`（Java）、`golang-jwt`（Go）。
- 中间件应在任何业务逻辑之前及时拒绝无效的 JWT。