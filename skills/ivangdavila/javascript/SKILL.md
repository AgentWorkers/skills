---
name: JavaScript
slug: javascript
version: 1.0.3
description: 使用异步模式、类型强制转换以及现代的 ES2023+ 特性来编写健壮的 JavaScript 代码。
---
## 使用场景

当用户需要掌握JavaScript的相关知识时（从核心语言特性到现代编程模式），该工具能够提供帮助。该工具能够处理异步/await、闭包、模块系统以及ES2023及更高版本的JavaScript特性。

## 快速参考

| 主题 | 文件名 |
|-------|------|
| 异步编程模式 | `async.md` |
| 类型强制转换规则 | `coercion.md` |
| 数组和对象方法 | `collections.md` |
| 现代JavaScript特性 | `modern.md` |

## 等值判断的陷阱

- `==` 会进行类型强制转换：`"0" == false` 的结果是 `true`——请始终使用 `===` 进行判断  
- `NaN !== NaN` — 应使用 `Number.isNaN()` 而不是 `=== NaN`  
- `typeof null === "object"` — 需要明确使用 `=== null` 进行判断  
- 对象的比较是基于引用的：`{} === {}` 的结果是 `false`  

## `this` 的绑定规则

- 普通函数中的 `this` 取决于调用位置——在回调函数中可能会丢失  
- 箭头函数中的 `this` 来自词法作用域——在回调函数中使用箭头函数或 `.bind()` 来确保正确的 `this` 值  
- `setTimeout(obj.method)` 会丢失 `this` 的引用——使用箭头函数或 `.bind()` 来解决这个问题  
- 事件处理函数中的 `this`：在普通函数中是当前元素，在箭头函数中是 `undefined`（如果没有外部 `this` 变量）  

## 闭包相关的陷阱

- 循环变量是通过引用捕获的——使用 `let` 在循环或立即执行函数（IIFE）中来确保变量的值不会被修改  
- 使用 `var` 定义的变量会被提升到函数作用域——这会导致所有迭代都共享同一个变量——建议使用 `let` 来避免这个问题  
- 从循环中返回函数时，所有迭代都会使用同一个变量——请为每次迭代都使用 `let` 定义变量  

## 数组操作

- `sort()`、`reverse()`、`splice()` 会修改原始数组——建议使用 `toSorted()`、`toReversed()`、`toSpliced()`（ES2023）等方法来创建副本  
- `push()`、`pop()`、`shift()`、`unshift()` 会修改原始数组——使用数组展开运算 `[...arr, item]` 可以得到不可变的副本  
- `delete arr[i]` 会删除数组中的元素并导致索引缺失——使用 `splice(i, 1)` 来删除元素并重新索引  

## 异步编程中的常见错误

- 忘记了 `await` 的返回值是一个 `Promise` 而不是具体的值——如果没有使用TypeScript，这很容易被忽略  
- `forEach` 方法不会等待每个异步操作的完成——对于顺序执行的异步操作，建议使用 `for...of`  
- `Promise.all` 会因为任何一个操作的失败而立即终止所有操作——如果需要获取所有结果，请使用 `Promise.allSettled`  
- 未处理的异常会导致Node.js程序崩溃——务必使用 `.catch()` 或 `try/catch` 语句来捕获异常  

## 数字相关操作

- `0.1 + 0.2 !== 0.3`——这是浮点数的精度问题，可以使用整数表示或使用 `toFixed()` 方法来格式化显示结果  
- `parseInt("08")` 现在可以正确解析为8——但 `parseInt("0x10")` 会解析为16，需要注意前缀  
- `Number("")` 的值是0，`Number(null)` 的值也是0——但 `Number(undefined)` 的值是 `NaN`  
- 大整数在超过2^53的范围后会丢失精度——对于大数值，请使用 `BigInt` 类型  

## 迭代操作

- `for...in` 会遍历对象的键（包括继承的键）——建议使用 `for...of` 来遍历对象的值  
- 对于对象，`for...of` 可能会失败——因为对象本身不是可迭代的，可以使用 `Object.entries()`  
- `Object.keys()` 会忽略不可枚举的键——`Reflect.ownKeys()` 可以获取对象的所有键（包括符号键）  

## 隐式类型转换

- `[] + []` 的结果是 `""`——数组会被强制转换为字符串  
- `[] + {}` 的结果是 `"[object Object]"`——数组会被转换为字符串  
- `{} + []` 在控制台中的结果是0——`{}` 被解析为一个对象，而不是数组  
- `"5" - 1` 的结果是4，`"5" + 1` 的结果是 "51"——减法操作会先进行类型转换，然后进行字符串连接  

## 严格模式

- 在文件或函数的顶部使用 `use strict` 可以捕获一些隐式的错误  
- 在严格模式下，未声明的变量会被视为全局变量并引发错误  
- 在严格模式下，`this` 的值是 `undefined`，而不是全局对象  
- 严格模式下不允许参数重复以及使用 `with` 语句