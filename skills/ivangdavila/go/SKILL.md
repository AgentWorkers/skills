---
name: Go
slug: go
version: 1.0.2
description: 编写可靠的 Go 代码，避免 goroutine 漏洞、接口陷阱以及常见的并发错误。
metadata: {"clawdbot":{"emoji":"🐹","requires":{"bins":["go"]},"os":["linux","darwin","win32"]}}
---

## 快速参考

| 主题 | 文件 |
|-------|------|
| 并发模式 | `concurrency.md` |
| 接口与类型系统 | `interfaces.md` |
| 切片、映射（Maps）、字符串 | `collections.md` |
| 错误处理模式 | `errors.md` |

## Goroutine（Goroutine）泄漏问题

- 如果 Goroutine 被阻塞在无发送者的通道上，它将永远处于阻塞状态——务必确保通道被关闭或使用上下文（context）来控制goroutine的生命周期。
- 未缓冲的通道在接收者未出现时会导致发送操作一直阻塞，从而引发死锁。
- 使用 `for range` 遍历通道时，如果通道未关闭，循环将永远执行下去——发送者必须调用 `close(ch)` 来关闭通道。
- 上下文（context）的取消操作不会自动停止 Goroutine 的执行——需要在循环中检查 `ctx.Done()` 来判断是否可以继续执行。
- 泄露的 Goroutine 会持续占用内存，且不会被垃圾回收系统回收。

## 通道（Channel）相关问题

- 向空通道（nil channel）发送数据会导致阻塞——从空通道接收数据也会导致阻塞。
- 向已关闭的通道发送数据会引发 panic。
- 只有发送者才能关闭通道——如果接收者尝试关闭通道，发送者也会引发 panic。
- 缓冲通道在满载时会导致发送操作阻塞——需要根据预期负载来设置缓冲区的大小。
- 使用 `select` 语句处理多个可用的通道时，选择是随机的，并非按照顺序执行。

## `defer` 语句相关问题

- `defer` 语句中的参数会在声明时立即被求值，而不是在 `defer` 函数执行时才求值——例如 `defer log(time.Now())` 会立即记录当前时间。
- 在循环中使用 `defer` 语句会导致栈空间累积——`defer` 语句会在函数结束时执行，而不是在每次迭代结束时执行。
- 即使发生 panic，`defer` 语句也会被执行——这有助于资源清理，但错误处理只能在 `defer` 函数中完成。
- 在 `defer` 语句中声明的返回值是可以被修改的——例如 `defer func() { err = wrap(err) }()` 是有效的。
- `defer` 语句的执行顺序是后进先出（LIFO）的——最后一个声明的 `defer` 语句会首先执行。

## 接口（Interface）相关问题

- 接口中包含 `nil` 具体类型（concrete type）的变量仍然属于 `interface` 类型——例如 `var p *MyType; var i interface{} = p; i != nil` 是合法的。
- 对错误类型的类型断言（type assertion）会引发 panic——应该使用 `v, ok := i.(Type)` 来安全地进行类型转换。
- 空接口 `any` 可以接受任何类型，但会失去类型安全性——应尽量避免使用。
- 接口的实现是隐式的——如果方法签名发生变化，编译器不会报错。
- 指针类型的接收者不满足接口要求——只有指针类型（如 `*T`）才能实现接口方法。

## 错误处理（Error Handling）

- 错误是值（values），而不是异常（exceptions）——务必检查返回的错误。
- 每次函数调用后都应检查 `err != nil`——未检查的错误会成为隐藏的漏洞。
- 使用 `errors.Is` 来判断错误类型——`==` 运算符不适用于使用 `fmt.Errorf("%w", err)` 创建的错误。
- 应该使用 `var ErrFoo = errors.New()` 来定义常量错误，避免重复创建错误对象。
- 只有程序员错误（programmer errors）才应该引发 panic——运行时错误应该通过返回错误来处理。

## 切片（Slice）相关问题

- 切片是对数组的引用——修改切片会修改原始数组。
- `append` 操作可能会重新分配内存，也可能不会——不要假设切片的容量会自动扩展。
- 切片操作不会复制数据——`a[1:3]` 会与 `a` 共享内存。
- `nil` 切片和空切片是不同的——`var s []int` 与 `s := []int{}` 是不同的。
- `copy()` 函数只会复制切片中的最小长度——不会扩展目标切片。

## 映射（Map）相关问题

- 从空映射中读取数据会返回零值——向空映射中写入数据会引发 panic。
- 映射的迭代顺序是随机的——不要依赖特定的迭代顺序。
- 映射不支持并发访问——应使用 `sync.Map` 或互斥锁（mutex）来保证安全性。
- 禁止获取映射元素的地址——`&m[key]` 会导致编译错误。
- 在迭代过程中删除元素是安全的，但添加元素可能会引发问题。

## 字符串（String）相关问题

- 字符串是不可变的字节切片——任何修改都会创建新的内存分配。
- 使用 `range` 遍历字符串时，实际上是遍历字节（rune），而不是字符。
- `len(s)` 返回的是字节的长度，而不是字符的数量——使用 `utf8.RuneCountInString()` 来获取正确的字符数量。
- 字符串比较是基于字节的——不是基于 Unicode 标准的。
- 子字符串会与原字符串共享内存——因此，大的字符串会占用更多的内存。

## 结构体（Struct）与内存（Memory）相关问题

- 结构体的字段会为了对齐而填充额外的字节——字段的顺序会影响内存占用。
- 可以为字段赋零值——例如 `var wg sync.WaitGroup` 可以直接使用，无需构造函数。
- 使用互斥锁复制结构体时，需要传递结构体的指针，而不是结构体本身。
- 嵌入（embedding）并不等同于继承——嵌入的方法可能会被隐藏。
- 导出的字段首字母需要大写——小写的字段在包外部是不可见的。

## 编译（Build）相关问题

- `go build` 会频繁缓存编译结果——使用 `-a` 标志可以强制重新编译。
- 未使用的导入语句会导致编译失败——使用 `_` 前缀的导入语句仅用于引入副作用。
- `init()` 函数会在 `main` 函数之前执行，其执行顺序取决于依赖关系，而不是文件顺序。
- `go:embed` 指令的路径是相对于源文件的——不是相对于工作目录的。
- 跨平台编译时，需要指定 `GOOS=linux` 和 `GOARCH=amd64`——编译完成后需要在目标平台上进行测试。