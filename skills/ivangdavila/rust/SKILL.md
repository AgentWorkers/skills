---
name: Rust
slug: rust
version: 1.0.1
description: 编写符合Rust语言习惯的代码，避免所有权（ownership）相关的陷阱、生命周期（lifetime）问题以及常见的借用检查（borrow checking）错误。
metadata: {"clawdbot":{"emoji":"🦀","requires":{"bins":["rustc","cargo"]},"os":["linux","darwin","win32"]}}
---
## 快速参考

| 主题 | 文件 | 常见陷阱 |
|-------|------|----------|
| 所有权与借用 | `ownership-borrowing.md` | 移动语义（move semantics）可能会引发问题 |
| 字符串与类型 | `types-strings.md` | `String` 与 `&str` 的区别，UTF-8 索引的使用 |
| 错误处理与迭代 | `errors-iteration.md` | 在生产环境中使用 `unwrap()`，以及懒惰迭代器的注意事项 |
| 并发与内存管理 | `concurrency-memory.md` | 使用 `Rc` 而不是 `Send`，`RefCell` 可能会导致 panic |
| 高级陷阱 | `advanced-traps.md` | 不安全的代码实践、宏的使用、跨语言调用（FFI）以及性能优化问题 |

---

## 高频出现的编译错误

### 所有权相关的问题（编译错误的常见原因）
- **变量在使用后被移动**：需要显式克隆或使用 `&` 进行借用。
- **`for item in vec` 会移动整个 `vec`：** 应使用 `&vec` 或 `.iter()` 来借用 `vec` 中的元素。
- **将 `String` 作为参数传递给函数**：如果需要只读访问，应传递 `&str`。

### 借用相关的问题
- **不能同时拥有 `&mut` 和 `&`：** 需要重新设计代码结构或使用 `RefCell` 来管理可变性。
- **返回对局部变量的引用会导致 panic**：应返回对该变量的所有权。
- **通过 `&mut self` 借用的可变变量会阻止所有访问**：需要将结构体拆分或使用 `RefCell`。

### 生命周期相关的问题（编译器无法推断的情况）
- `'static` 标志表示变量可以“永远存在”，但并不意味着它一定存在：`String` 类型可以被标记为 `static`。
- **包含引用的结构体需要指定生命周期：** 例如 `struct Foo<'a> { bar: &'a str }`。
- **返回引用类型的函数必须与输入参数的生命周期一致：** `fn get<'a>(s: &'a str) -> &'a str`。

### 字符串相关的问题（UTF-8 编译错误）
- `s[0]` 无法编译：应使用 `.chars().nth(0)` 或 `.bytes()` 来获取字符。
- `.len()` 返回的是字节数而不是字符数：应使用 `.chars().count()`。
- `s1 + &s2` 会移动 `s1`：应使用 `format!("{}%", s1, s2)` 来避免这种情况。

### 错误处理（生产环境中的注意事项）
- 在生产代码中避免使用 `unwrap()`，因为它可能导致 panic：应使用 `?` 或 `match` 来处理错误。
- `?` 操作符需要 `Result` 或 `Option` 类型的返回值：函数签名应为 `-> Result<>`。
- `expect("context")` 应优先于 `unwrap()`，因为它能更好地显示错误发生的原因。

### 迭代器相关的问题
- `.iter()` 用于借用数据，`.into_iter()` 用于移动数据：需谨慎选择。
- `.collect()` 需要指定返回类型：应使用 `collect::<Vec<_>>()` 或进行类型绑定。
- 迭代器是惰性的：只有在被遍历时才会执行相关操作。

### 并发相关的问题（线程安全）
- `Rc` 不等同于 `Send`：在多线程环境中应使用 `Arc` 来管理引用。
- `Mutex` 的锁会自动释放：在释放锁时不需要手动解锁，也不要在 `await` 语句中持有锁。
- `RwLock` 可能导致死锁：读取者升级为写入者时会永远阻塞。

### 内存管理相关的问题（智能指针）
- `RefCell` 在运行时可能会因为违反借用规则而引发 panic。
- 对于递归类型，应使用 `Box` 来包装引用。
- 避免使用复杂的 `Rc<RefCell<T>>` 结构：需要重新考虑引用的所有权模型。

---

## 常见的编译错误（新出现的）

| 错误 | 原因 | 解决方法 |
|-------|-------|-----|
| 变量在移动后被再次使用 | 应先克隆或借用变量。 |
| 无法将不可变变量作为可变变量借用 | 可能是因为变量已经被借用，需要重新设计代码或使用 `RefCell`。 |
| 缺少生命周期指定符 | 可能是因为引用不明确，需要添加 `<'a>` 类型限定符。 |
- 特性绑定不满足要求 | 可能是因为缺少实现，需要检查相关实现。 |
- 需要类型注释：编译器可能无法推断类型，需要手动指定类型。 |
- 无法从被借用的数据中移动变量：可能是因为使用了 `Deref` 操作，需要重新克隆变量或使用模式匹配来解决问题。 |

---

## Cargo 配置相关的问题（新出现的）

- `cargo update` 会更新 `Cargo.lock` 文件，而不是 `Cargo.toml`：需要手动升级 Cargo 版本。
- 某些功能是可选项（`features`），无法禁用依赖项所启用的功能。
- `[dev-dependencies]` 通常只包含在测试或示例代码中，不会被包含在最终发布的二进制文件中。
- `cargo build --release` 的编译速度更快，但调试版本故意设计得较慢。