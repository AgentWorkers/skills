---
name: database-migrations
model: standard
description: 安全、无中断的数据库迁移策略——适用于生产系统的模式演进、回滚计划、数据迁移、工具支持以及避免常见迁移错误的方法。在规划模式变更、编写迁移脚本或评估迁移安全性时，请参考这些策略。
---

# 数据库迁移模式

## 架构演进策略

| 策略 | 风险 | 停机时间 | 适用场景 |
|----------|------|----------|----------|
| **仅添加新字段** | 风险极低 | 无 | 具有向后兼容性保证的API |
| **扩展/收缩字段** | 风险较低 | 无 | 适用于字段重命名、结构调整或类型变更 |
| **并行修改** | 风险较低 | 无 | 适用于对关键表进行高风险修改 |
| **延迟迁移** | 风险中等 | 无 | 适用于数据量较大的表，批量迁移速度较慢的情况 |
| **一次性迁移** | 风险较高 | 有 | 仅适用于开发环境或数据量较小的场景 |

**默认策略为“仅添加新字段”。**只有在必须修改或删除现有结构时，才采用“扩展/收缩字段”策略。

---

## 零停机时间迁移策略

所有生产环境中的迁移操作都必须避免锁定表或破坏正在运行的应用程序代码。

| 操作 | 迁移策略 | 关键约束 |
|-----------|---------|----------------|
| **添加列** | 允许字段为空 | 在大型表上，切勿在没有默认值的情况下直接设置`NOT NULL` |
| **重命名列** | 使用“扩展-收缩”策略 | 先创建新列，同时写入旧列和新列的数据，然后回填数据，最后切换读取路径并删除旧列 |
| **删除列** | 先将列标记为过时 | 停止读取数据，停止写入数据，部署新结构后删除旧列 |
| **修改列类型** | 并行操作 | 先创建新类型的列，然后同时写入新旧列的数据，之后切换读取路径并删除旧列 |
| **添加索引** | 并发操作 | 使用`CREATE INDEX CONCURRENTLY`语句，避免使用事务 |
| **拆分表** | 提取数据并创建外键 | 创建新表，回填数据，添加外键，更新查询语句，最后删除旧表 |
| **修改约束** | 分两阶段进行 | 先添加`NOT VALID`约束，之后使用`VALIDATE CONSTRAINT`语句 |

---

## 迁移工具

| 工具 | 开发语言/框架 | 代码风格 | 主要优势 |
|------|-----------|-------|-------------|
| **Prisma Migrate** | TypeScript/Node.js | 声明式（基于架构差异的迁移） | 支持ORM集成，提供影子数据库功能 |
| **Knex** | JavaScript/Node.js | 命令式（用于升级/降级数据库结构） | 体积轻量，灵活性高 |
| **Drizzle Kit** | TypeScript/Node.js | 声明式（基于架构差异的迁移） | 类型安全，语法类似SQL |
| **Alembic** | Python | 命令式（用于数据库结构的升级/降级） | 提供细粒度控制，支持自动生成迁移脚本 |
| **Django Migrations** | Python/Django | 声明式（基于模型差异的迁移） | 具有自动检测功能 |
| **Flyway** | Java/JVM / 命令行工具 | 支持SQL文件版本控制 | 使用简单，支持多种数据库类型 |
| **golang-migrate** | Go语言 / 命令行工具 | 通过SQL文件进行迁移操作 | 代码简洁，易于集成 |
| **Atlas** | Go语言 / 命令行工具 | 声明式（基于HCL/SQL差异的迁移） | 支持将架构差异转换为代码，提供代码检查功能 |

根据你的ORM和部署流程选择合适的迁移工具。对于简单的架构，建议使用声明式迁移工具；对于需要精细控制数据操作的场景，可以使用命令式迁移工具。

---

## 回滚策略

| 回滚方法 | 适用场景 |
|----------|-------------|
| **可逆迁移** | 仅涉及架构变更的早期阶段产品 |
| **单向迁移** | 会对数据造成破坏的变更，适用于生产环境 |
| **混合策略** | 架构变更采用可逆方式，数据变更采用单向迁移 |

### 数据保护措施

1. **软删除列**：使用`_deprecated`后缀重命名列，而不是直接删除 |
2. **创建备份表**：使用`CREATE TABLE _backup_<table>_<date> AS SELECT * FROM <table>`创建备份表 |
3. **确保数据备份**：确保WAL（Write-Ahead Log）备份机制覆盖迁移期间产生的数据 |
4. **进行逻辑备份**：在迁移前对受影响的表进行`pg_dump`备份 |

### 蓝绿部署（Blue-Green Deployment）技术

```
1. Replicate primary → secondary (green)
2. Apply migration to green
3. Run validation suite against green
4. Switch traffic to green
5. Keep blue as rollback target (N hours)
6. Decommission blue after confidence window
```

---

## 数据迁移策略

### 数据回填策略

| 策略 | 适用场景 |
|----------|----------|
| **内联回填** | 数据量较小的表（少于10万行） |
| **批量回填** | 数据量中等的表（10万至1000万行） |
| **后台作业** | 数据量较大的表（超过1000万行） |
| **延迟回填** | 当不需要立即保持数据一致性时 |

### 批量处理

```sql
DO $$
DECLARE
  batch_size INT := 1000;
  rows_updated INT;
BEGIN
  LOOP
    UPDATE my_table
    SET new_col = compute_value(old_col)
    WHERE id IN (
      SELECT id FROM my_table
      WHERE new_col IS NULL
      LIMIT batch_size
      FOR UPDATE SKIP LOCKED
    );
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    EXIT WHEN rows_updated = 0;
    PERFORM pg_sleep(0.1);  -- throttle to reduce lock pressure
    COMMIT;
  END LOOP;
END $$;
```

### 双写机制（Dual-Write Mechanism）

在采用“扩展/收缩字段”或“并行修改”策略时，需要执行以下步骤：

1. **同时写入**：应用程序同时向旧表和新表写入数据 |
2. **回填数据**：将历史数据填充到新表中 |
3. **验证数据一致性**：检查数据行数和校验和是否正确 |
4. **切换读取路径**：将读取操作切换到新表，停止写入旧表 |
5. **清理旧表**：在迁移完成后删除旧表结构 |

---

## 迁移测试

### 使用真实生产环境的数据进行测试

- **切勿仅使用空数据或合成数据进行测试** |
- **使用匿名化的生产环境数据副本** |
- **确保测试数据量与实际生产环境一致**：在1000行数据上成功的迁移操作可能在1000万行数据上出现问题 |
- **重现边界情况**：测试包含NULL值、空字符串、最大长度限制以及Unicode字符等情况的数据 |

### 迁移的持续集成（CI）流程

每个迁移相关的代码提交（PR）都必须经过以下测试步骤：先进行“升级”操作，然后进行“降级”操作，最后再次进行“升级”操作，最后进行测试。

---

## 迁移检查清单

### 迁移前的准备

- [ ] 使用真实生产环境的数据量进行了测试 |
- [ ] 回滚方案已编写并经过测试 |
- [ ] 已创建受影响表的备份 |
- [ ] 应用程序代码与旧架构和新架构兼容 |
- [ ] 在测试环境中测试了迁移的执行时间 |
- [ ] 分析了迁移操作对系统锁定的影响 |
- [ ] 已设置好复制延迟的监控机制 |

### 迁移过程中的监控

- [ ] 监控迁移过程中的锁定等待时间和活跃查询数量 |
- [ ] 监控数据复制延迟 |
- [ ] 注意错误率的突然上升 |
- [ ] 准备好回滚命令 |

### 迁移后的验证

- [ ] 确认架构符合预期状态 |
- [ ] 集成测试通过 |
- [ ] 验证数据完整性（包括数据行数和校验和） |
- [ ] 更新ORM中的架构定义和类型信息 |
- [ ] 在迁移完成后清理过时的数据结构 |
- [ ] 将迁移过程记录在团队运行手册中 |

---

## 绝对禁止的操作

1. **绝对禁止** 在生产环境中直接运行未经测试的迁移脚本 |
2. **绝对禁止** 在不先删除所有应用程序引用并完成部署的情况下直接删除列 |
3. **绝对禁止** 在单条SQL语句中向大型表添加`NOT NULL`约束且不设置默认值 |
4. **绝对禁止** 在同一个迁移文件中同时包含架构修改和数据更新操作 |
5. **绝对禁止** 在实时系统中重命名列时跳过“同时写入”步骤 |
6. **绝对禁止** 假设迁移操作可以瞬间完成——务必在实际生产环境的数据上进行测试 |
7. **绝对禁止** 为“加速”迁移过程而禁用外键检查 |
8. **绝对禁止** 在迁移完成之前部署依赖于架构变更的应用程序代码