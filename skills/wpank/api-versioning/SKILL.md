---
name: api-versioning
model: standard
description: API版本管理策略：包括URL路径设计、请求头（header）的设置、查询参数（query param）的利用以及内容协商（content negotiation）的方法。这些策略还涵盖了重大变更（breaking changes）的分类、功能废弃（deprecation）的时间表、迁移方案（migration patterns）以及多版本支持（multi-version support）。这些方法在API的演进过程中非常有用，可用于规划重大变更、管理API的生命周期（version lifecycle）。
---

# API版本控制模式

自信地发展您的API。正确地进行版本更新，优雅地淘汰旧版本，并安全地迁移——同时确保现有客户端不受影响。

## 版本控制策略

选择一种策略，并在整个API中一致地应用它。

| 策略 | 格式 | 可见性 | 可缓存性 | 适用场景 |
|----------|--------|------------|--------------|----------|
| **URL路径** | `/api/v1/users` | 高 | 非常好 | 公开API、第三方集成 |
| **查询参数** | `/api/users?v=1` | 中等 | 一般 | 简单API、原型设计 |
| **请求头** | `Accept-Version: v1` | 低 | 一般 | 内部API、协同使用的客户端 |
| **内容协商** | `Accept: application/vnd.api.v1+json` | 低 | 一般 | 企业级应用、严格的REST合规性 |

---

## URL路径版本控制

最常见的策略。版本信息直接体现在URL中，便于立即识别。

**规则：**
- 必须始终使用前缀 `/api/v1/`，而不是 `/v1/api/`  
- 只使用主版本号，例如 `/api/v1/`，避免使用 `/api/v1.2/` 或 `/api/v1.2.3/`  
- 每个API端点都必须有版本标识，不能混合使用有版本标识和没有版本标识的路径  

## 请求头版本控制

通过请求头指定版本信息，保持URL的简洁性。

**规则：**
- 当没有发送版本头时，必须定义回退行为——默认返回最新稳定版本或 `400 Bad Request` 错误。  

## API的语义版本控制

| 版本变更类型 | API含义 | 客户端需要采取的行动 |
|------------------|-------------|-----------------|
| **重大版本变更** (v1 → v2) | 会导致功能破坏——例如删除字段、重命名端点、更改认证方式 | 客户端必须进行迁移 |
| **次要版本变更** (v1.1 → v1.2) | 添加新字段或新端点——向后兼容 | 客户端无需更改 |
| **修补版本变更** (v1.1.0 → v1.1.1) | 修复错误，不改变现有功能 | 客户端无需更改 |

只有重大版本号会体现在URL路径中。次要版本和修补版本变更通过变更日志进行沟通。  

## 破坏性变更与非破坏性变更

### 破坏性变更——需要新版本

| 变更类型 | 会导致的问题 |
|--------|---------------|
| 删除响应字段 | 客户端读取该字段时会得到 `undefined` |
| 重命名字段 | 对客户端来说，相当于删除了该字段 |
| 更改字段类型 | 例如将 `"id": 123` 更改为 `"id": "123"` 会导致类型不匹配的错误 |
| 删除端点 | 客户端调用该端点时会收到 `404` 错误 |
| 将可选参数变为必填 | 未提供该参数的现有请求会失败 |
| 更改URL结构 | 预先标记或硬编码的URL会失效 |
| 更改错误响应格式 | 客户端的错误处理逻辑会出错 |
| 更改认证方式 | 现有的认证信息将不再有效 |

### 非破坏性变更——在同一版本下安全进行

| 变更类型 | 为何安全 |
|--------|---------------|
| 添加新的可选响应字段 | 客户端可以忽略未知字段 |
| 添加新的端点 | 不影响现有端点 |
| 添加新的可选查询参数/请求体参数 | 现有请求仍可正常工作 |
| 添加新的枚举值 | 如果客户端能够优雅地处理未知值，则安全 |
| 放松验证规则 | 之前有效的请求仍然有效 |
| 提高性能 | 接口不变，响应速度更快 |

## 废弃策略

切勿在未发出警告的情况下删除某个版本。遵循以下时间表：

**最低废弃周期：**
- 公开API：12个月  
- 合作伙伴API：6个月  
- 内部API：1–3个月  

### 日落HTTP头（RFC 8594）

在来自废弃版本的每个响应中都必须包含以下头信息：

---

## 废弃版本的响应处理

当版本达到废弃期限后，返回 `410 Gone` 状态码：

---

## 迁移策略

### 适配器模式

共享业务逻辑，针对不同版本使用不同的序列化方式：

---

### 外观模式

通过单一入口点将请求转发到正确的版本处理程序：

---

### 分版本控制器

为每个版本创建独立的控制器文件，并共享服务层：

---

### API网关路由

在基础设施层对不同版本进行路由处理：

---

## 多版本支持

**架构：**

---

**原则：**
1. **业务逻辑与版本无关。** 服务、仓库和领域模型都是共享的。
2. **序列化方式与版本相关。** 每个版本都有自己对应的请求验证器和响应序列化器。
3. **转换规则明确。** 有一个 `v1_to_v2` 的转换工具，用于记录每个字段的映射关系。
4. **测试覆盖所有活跃版本。** 每个支持的版本都有对应的集成测试套件。

**最大同时支持的版本数量：** 2–3个活跃版本（当前版本加上1–2个废弃版本）。超过3个版本会导致维护负担过重。

## 客户端沟通

### 变更日志

为每次发布生成变更日志，并按版本和变更类型进行标记：

---

### 迁移指南

对于每次重大版本更新，提供以下内容：
- 字段之间的映射表（例如 v1 → v2）
- 请求和响应的示例（更新前/更新后）
- 常见语言/SDK的代码示例
- 包含关键日期的时间线（发布日期、废弃日期、移除日期）

### SDK版本控制

确保SDK的版本号与API的版本号保持一致：

---

**注意：** 在宣布API废弃之前，先发布新的SDK版本。

---

## 应避免的错误做法

| 错误做法 | 应该如何改进 |
|-------------|-----|
| **频繁进行版本更新** | 将破坏性变更分批放入不频繁的重大版本更新中 |
| **未经通知就进行破坏性变更** | 始终遵循废弃时间表 |
| **永久支持所有版本** | 设定并严格执行废弃日期 |
| **版本控制不一致** | 使用统一的版本控制方案 |
| **每个端点都使用不同的版本号** | 应为整个API统一设置版本号 |
| **使用版本号来控制功能启用/禁用** | 应使用功能标志来控制功能的启用/禁用；版本号用于明确功能的使用范围 |
| **不设置默认版本** | 必须设置默认版本，或明确返回 `400` 错误 |

---

**绝对禁止的做法：**
1. **绝对禁止** 在不升级主版本的情况下删除字段、端点或更改字段类型。
2. **绝对禁止** 在提前少于6个月的情况下废弃公开API版本。
3. **绝对禁止** 在同一个API中混合使用不同的版本控制策略（例如某些端点使用URL路径，某些端点使用请求头）。
4. **绝对禁止** 在URL路径中使用次要或修补版本号（例如 `/api/v1.2/` 是错误的做法，应使用 `/api/v1/`）。
5. **绝对禁止** 独立地为单个端点设置版本号——应为整个API统一设置版本号。
6. **绝对禁止** 在现有版本号下部署破坏性变更，即使“没有人使用某个字段”。
7. **绝对禁止** 不记录版本之间的差异——每个破坏性变更都需要有详细的迁移指南。