---
name: caching
model: standard
description: 缓存策略、失效机制、淘汰策略、HTTP缓存、分布式缓存以及相关反模式（anti-patterns）。这些内容在设计缓存层、选择淘汰策略、调试过期数据或优化以读取操作为主的工作负载时非常有用。
---

# 缓存模式

> 正确放置的缓存是提升系统速度最经济的方式；而错误放置的缓存则可能导致大量错误（即“bug”）的产生。

## 缓存策略

| 策略 | 工作原理 | 使用场景 |
|----------|-------------|-------------|
| **缓存旁路（惰性缓存）** | 应用程序首先检查缓存，如果缓存不存在，则从数据库读取数据并写入缓存 | **默认选择**——通用场景 |
| **直接读取** | 当缓存不存在时，自动从数据库读取数据 | 集成ORM的缓存系统、CDN源服务器的数据获取 |
| **直接写入** | 数据同时写入缓存和数据库 | 以读取为主的应用场景，要求数据强一致性 |
| **延迟写入** | 数据先写入缓存，再异步刷新到数据库 | 需要高写入吞吐量的场景，可接受数据最终一致性 |
| **提前刷新** | 在缓存过期前主动刷新缓存 | 访问模式可预测，对低延迟有严格要求的应用场景 |

```
Cache-Aside Flow:

  App ──► Cache ──► HIT? ──► Return data
              │
              ▼ MISS
          Read DB ──► Store in Cache ──► Return data
```

---

## 缓存失效机制

| 方法 | 一致性 | 使用场景 |
|--------|-------------|-------------|
| **基于TTL** | 数据最终会失效（直到TTL时间） | 适用于简单数据，可接受数据短暂失效 |
| **基于事件** | 数据几乎实时更新 | 例如库存信息、用户资料更新 |
| **基于版本** | 数据版本固定 | 适用于静态资源、API响应、配置信息 |
| **基于标签** | 数据具有唯一标签 | 适用于内容管理系统（CMS）中的内容、按类别清理缓存 |

### TTL（时间到期）指南

| 数据类型 | TTL（时间到期值） | 选择理由 |
|-----------|-----|-----------|
| 静态资源（CSS/JS/图片） | 1年 + 使用缓存破坏哈希值 | 文件名决定了数据的唯一性 |
| API配置/功能开关 | 30–60秒 | 需要快速传播更新 |
| 用户资料数据 | 5–15分钟 | 可接受数据短暂失效 |
| 产品目录信息 | 1–5分钟 | 在数据新鲜度和系统负载之间取得平衡 |
| 会话数据 | 与会话超时时间一致 | 为了安全考虑 |

---

## HTTP缓存

### Cache-Control指令

| 指令 | 含义 |
|-----------|---------|
| `max-age=N` | 缓存有效期为N秒 |
| `s-maxage=N` | CDN或共享缓存的最大有效期（覆盖`max-age`指令） |
| `no-cache` | 使用缓存副本前必须重新验证数据 |
| `no-store` | 绝不在任何地方缓存数据 |
| `must-revalidate` | 数据失效后必须重新验证 |
| `private` | 仅允许浏览器缓存，不允许CDN缓存 |
| `public` | 允许任何缓存服务器缓存数据 |
| `immutable` | 内容在有效期内永远不会改变 |
| `stale-while-revalidate=N` | 在获取新数据前，继续提供失效的缓存内容N秒 |

### 常见缓存策略

```
# Immutable static assets (hashed filenames)
Cache-Control: public, max-age=31536000, immutable

# API response, CDN-cached, background refresh
Cache-Control: public, s-maxage=60, stale-while-revalidate=300

# Personalized data, browser-only
Cache-Control: private, max-age=0, must-revalidate
ETag: "abc123"

# Never cache (auth tokens, sensitive data)
Cache-Control: no-store
```

### 条件请求

| 机制 | 请求头 | 响应头 | 工作原理 |
|-----------|---------------|-----------------|-------------|
| **ETag** | `If-None-Match: "abc"` | `ETag: "abc"` | 基于哈希值判断；如果匹配则返回404状态码 |
| **Last-Modified** | `If-Modified-Since: <date>` | `Last-Modified: <date>` | 基于修改时间判断；如果数据未更改则返回404状态码 |

建议优先使用ETag而非`Last-Modified`——ETag能更准确地检测数据是否发生变化，不受时间戳粒度的影响。

---

## 应用程序缓存

| 解决方案 | 提升速度效果 | 是否可在多个进程间共享 | 使用场景 |
|----------|-------|------------------------|-------------|
| **内存LRU缓存** | 最快 | 不能 | 单进程环境，内存有限，适用于热点数据 |
| **Redis** | 几毫秒（网络传输时间） | 可 | **生产环境默认选择**——支持TTL、发布/订阅（Pub/Sub）机制，支持数据持久化 |
| **Memcached** | 几毫秒（网络传输时间） | 可 | 适用于大规模的简单键值存储场景 |
| **SQLite** | 快速（磁盘存储） | 不支持 | 适用于嵌入式应用、边缘缓存场景 |

### Redis与Memcached的比较

| 特性 | Redis | Memcached |
|---------|-------|-----------|
| 数据结构 | 字符串、哈希值、列表、集合、有序集合 | 仅支持字符串 |
| 数据持久化 | AOF（追加文件）/RDB快照 | 不支持持久化 |
| 发布/订阅（Pub/Sub） | 支持 | 不支持 |
| 最大值大小 | 512 MB | 1 MB |
| **推荐选择** | 大规模场景下的纯缓存解决方案 |

---

## 分布式缓存

| 需要考虑的问题 | 解决方案 |
|---------|----------|
| **分区** | 使用一致性哈希算法，减少节点变化时的数据重新分配 |
| **复制** | 主从复制机制——数据写入主节点，从节点读取数据 |
| **故障转移** | 使用Redis Sentinel或集群自动故障转移机制 |

**经验法则：** 生产环境的Redis集群至少需要3个主节点和3个从节点。

---

## 缓存淘汰策略

| 策略 | 工作原理 | 使用场景 |
|--------|-------------|-------------|
| **LRU（最近最少使用）** | 淘汰最近最少被访问的数据 | **默认策略**——通用场景 |
| **LFU（最少使用频率）** | 淘汰使用频率最低的数据 | 适用于数据访问分布不均匀的情况 |
| **FIFO（先进先出）** | 淘汰最旧的数据 | 适用于数据按时间顺序存储的场景 |
| **基于TTL** | 在指定时间后淘汰数据 | 适用于数据有明确有效期的情况 |

> Redis的默认缓存淘汰策略是`noeviction`。在生产环境中，建议将`maxmemory-policy`设置为`allkeys-lru`或`volatile-lru`。

---

## 缓存层次结构

```
Browser Cache → CDN → Load Balancer → App Cache → DB Cache → Database
```

| 缓存层次 | 缓存内容 | 失效判断方式 |
|-------|--------------|--------------|
| **浏览器缓存** | 静态资源、API响应 | 使用版本号和`Cache-Control`头进行缓存控制 |
| **CDN缓存** | 静态文件、公共API响应 | 定期清理缓存，使用代理键（surrogate keys） |
| **应用程序缓存** | 计算结果、数据库查询结果、外部API调用 | 基于事件触发，使用TTL机制 |
| **数据库缓存** | 查询计划、缓冲池、物化视图 | 使用`ANALYZE`命令手动刷新缓存 |

---

## 防止缓存雪崩

当一个热点数据的关键字过期时，大量请求会同时访问数据库，可能导致系统崩溃。

| 技术手段 | 工作原理 |
|-----------|-------------|
| **互斥锁/锁定** | 首个请求获取锁，读取数据后更新缓存；其他请求等待 |
| **随机提前失效** | 在缓存过期前随机触发数据更新 |
| **请求合并** | 合并针对同一关键字的所有请求 |
| **失效时继续提供旧缓存** | 在更新新数据前继续提供失效的缓存内容 |

---

## 缓存预热

| 策略 | 使用场景 |
|----------|-------------|
| **部署时预热** | 需要预热的缓存键集，对延迟敏感 |
| **后台任务** | 数据报告、仪表盘展示、产品目录数据更新 |
| **新基础设施部署** | 在新系统上线时进行缓存迁移 |
| **基于优先级的预热** | 预热时间有限 |

> **注意：** 完全清除缓存可能会导致数据库负载增加10–100倍。建议逐步预热缓存，或使用`stale-while-revalidate`策略。

## 监控

| 监控指标 | 正常范围 | 异常情况时的处理措施 |
|--------|--------------|---------------------|
| **命中率** | > 90% | 缓存容量太小、TTL设置不当或缓存键设计不合理 |
| **淘汰率** | 接近0% | 内存使用率过高，需要增加缓存容量或调整缓存策略 |
| **延迟（99百分位）** | < 1ms（对于Redis） | 延迟过高可能是网络问题或缓存数据量过大 |
| **内存使用率** | < 最大内存容量的80% | 内存使用率接近上限时，需要扩展缓存容量或调整缓存策略 |

## 绝对不能做的事情：

1. **绝不要在没有设置TTL或失效机制的情况下使用缓存**——否则数据会永久失效 |
2. **绝不要将缓存视为持久化存储**——缓存数据可能会丢失或损坏，遇到问题时必须回退到原始数据源 |
3. **绝不要对敏感数据（如令牌、个人身份信息）使用不加密的缓存**——缓存泄露会导致数据泄露 |
4. **绝不要忽视热点数据的缓存雪崩问题**——一个过期的热点数据可能导致整个系统崩溃 |
5. **绝不要在生产环境中使用无限制的内存缓存**——否则内存使用量可能会无限增长，导致系统崩溃 |
6. **绝不要使用`immutable`的`Cache-Control`头来缓存可变数据**——浏览器不会重新请求这些数据 |
7. **绝不要忽略对缓存命中率和失败率的监控**——只有通过监控才能了解缓存是否发挥了作用 |

---

（注：由于文档内容较长，部分翻译采用了分段处理的方式，以确保翻译的连贯性和可读性。）