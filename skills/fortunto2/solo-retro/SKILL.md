---
name: solo-retro
description: **流程后回顾**：解析日志，评估流程质量，发现浪费现象，并提出相应的技能/脚本优化建议。该功能适用于流程完成后，或当用户请求“进行回顾”、“评估流程”、“分析问题所在”、“进行流程审查”或“查看流程日志”时使用。
license: MIT
metadata:
  author: fortunto2
  version: "2.0.0"
  openclaw:
    emoji: "🔮"
allowed-tools: Read, Grep, Bash, Glob, Write, Edit, AskUserQuestion, mcp__solograph__session_search, mcp__solograph__codegraph_explain, mcp__solograph__codegraph_query
argument-hint: "[project-name]"
---
# /retro

本技能是独立完成的——请按照以下步骤操作，无需依赖其他技能（如 `/review`、`audit`、`build`）或创建任务子代理。所有分析工作均需直接执行。

**后管道回顾**：解析 Big Head 管道日志，统计有效迭代与无效迭代的次数，识别重复出现的故障模式，对管道运行进行评分，并提出具体的修改建议，以防止类似故障再次发生。

## 使用时机

在 Big Head 管道完成（或被取消）后执行。此过程用于检查质量：`/review` 检查代码质量，`/retro` 检查管道流程质量。

也可独立应用于任何有管道日志的项目。

## MCP 工具（如有可用）

- `session_search(query)` — 查找过去的管道运行记录和已知问题
- `codegraph_explain(project)` — 了解项目架构背景
- `codegraph_query(query)` — 查询项目代码图的元数据

如果 MCP 工具不可用，可改用 Glob + Grep + Read 进行手动处理。

## 第 1 阶段：定位相关文件

1. **从 `$ARGUMENTS` 或当前工作目录（CWD）中确定项目名称**：
   - 如果提供了参数：使用该参数作为项目名称
   - 否则：从 CWD 的文件名中提取（例如：`~/startups/active/life2film` → `life2film`）

2. **查找管道状态文件**：`~/.solo/pipelines/solo-pipeline-{project}.local.md`
   - 如果存在：说明管道仍在运行或未清理干净——读取 YAML 文件中的 `project_root` 信息
   - 如果不存在：说明管道已完成——将 `~/startups/active/{project}` 作为项目根目录

3. **验证文件是否存在（并行读取）**：
   - 管道日志：`{project_root}/.solo/pipelines/pipeline.log`（必需文件，缺失则中止）
   - 迭代日志：`{project_root}/.solo/pipelines/iter-*.log`
   - 进度文件：`{project_root}/.solo/pipelines/progress.md`
   - 计划完成目录：`{project_root}/docs/plan-done/`
   - 活动计划文件：`{project_root}/docs/plan/`

4. **统计迭代日志数量**：`ls {project_root}/.solo/pipelines/iter-*.log | wc -l`
   - 报告：`找到 {N} 个迭代日志`

## 第 2 阶段：解析管道日志（定量分析）

完整读取 `pipeline.log`，逐行解析日志标签以提取结构化数据：

**日志格式**：`[HH:MM:SS] TAG | message`

**按标签提取信息**：

| 标签 | 需要提取的内容 |
|-----|----------------|
| `START` | 管道运行开始标记——统计重启次数（多个 START 表示多次重启） |
| `STAGE` | `iter N/M \| stage S/T: {stage_id}` — 每个阶段的迭代次数 |
| `SIGNAL` | `<solo:done/>` 或 `<solo:redo/>` — 表示某个阶段已完成 |
| `INVOKE` | 调用的技能——提取技能名称，并检查是否有错误 |
| `ITER` | `commit: {sha} \| result: {stage complete\|continuing}` — 每次迭代的结果 |
| `CHECK` | `{stage} \| {path} -> FOUND\|NOT FOUND` — 文件检查的结果 |
| `FINISH` | `Duration: {N}m` — 每次运行的总耗时 |
| `MAXITER` | `Reached max iterations ({N})` — 达到最大迭代次数 |
| `QUEUE` | 计划循环事件（激活、归档等） |
| `CIRCUIT` | 电路断路器触发（如果存在） |
| `CWD` | 工作目录变更 |
| `CTRL` | 控制信号（暂停/停止/跳过） |

**计算指标**：（具体计算逻辑在 **CODE_BLOCK_0___** 中）

## 第 3 阶段：解析 `progress.md`（定性分析）

读取 `progress.md` 并查找错误模式：

1. **未知技能错误**：查找 `Unknown skill:`，提取出出错的技能名称
2. **无效迭代**：查看“最后 5 行”仅显示错误或会话标题（未实际执行任何操作）的迭代
3. **重复错误**：连续迭代中出现的相同错误——表明存在循环问题
4. **重复的完成信号**：在同一迭代中多次出现 `<solo:done/>`——属于轻微异常（记录但不影响评分）

对于每个发现的错误模式，记录以下信息：
- 错误模式名称
- 首次出现的位置（迭代编号）
- 总出现次数
- 最长连续出现次数

## 第 4 阶段：分析迭代日志（基于样本）

**不要读取所有迭代日志**（可能超过 60 条）——采用智能采样方法：

1. **每个错误模式的第一个失败迭代**：对于第 3 阶段中发现的每个错误模式，读取第一个显示该错误的迭代日志
   - 读取时去除 ANSI 编码：`sed 's/\x1b\[[0-9;]*m//g' < iter-NNN-stage.log | head -100`

2. **每个阶段的首个成功迭代**：对于每个最终成功的阶段，读取第一个成功的迭代日志
   - 查找输出中的 `<solo:done/>`

3. **最终审核迭代**：读取最后一个 `iter-*-review.log`（审核结果）

4. **从每个样本日志中提取以下信息**：
   - 调用的工具（统计 `tool_use` 标签的出现次数）
   - 遇到的错误（使用 `grep` 查找 `Error`、`error`、`Unknown`、`failed`）
   - 完成信号（`<solo:done/>` 或 `<solo:redo/>` 是否存在）
   - 前 5 行和最后 10 行的内容（忽略空白行）

## 第 5 阶段：检查计划执行情况

对于 `docs/plan-done/` 和 `docs/plan/` 目录下的每个项目，执行以下操作：

1. **读取 spec.md**（如果存在）：
   - 统计满足的验收标准数量（`- [ ]` 和 `- [x]` 标签）
   - 计算满足标准的比例：`criteria_met = checked / total * 100`

2. **读取 plan.md**（如果存在）：
   - 统计任务数量（`- [ ]` 和 `- [x]` 标签）
   - 统计阶段数量（## 标签）
   - 检查 SHA 注解（`<!-- sha:... -->`）
   - 计算完成的任务比例：`tasks_done = checked / total * 100`

3. **编译每个阶段的总结**：
   - 阶段 ID、满足标准的比例、完成的任务比例、是否有 SHA 标注

## 第 6 阶段：Git 和代码质量（简要检查）

仅进行快速检查——非全面的质量评估：

1. **提交记录和格式**：（具体代码在 **CODE_BLOCK_1___** 中）
   - 统计符合常规格式的提交（`feat:`, `fix:`, `chore:`, `test:`, `docs:`, `refactor:`, `build:`, `ci:`, `perf:`）
   - 计算符合常规格式的提交比例：`conventional_pct = conventional / total * 100`

2. **提交者分布**：（具体代码在 **CODE_BLOCK_2___** 中）

3. **测试状态**（如果 CLAUDE.md 或 package.json 中有测试命令）：
   - 运行测试套件，记录通过/失败次数
   - 如果未找到测试命令，跳过并标记为“未配置测试”

4. **构建状态**（如果存在构建命令）：
   - 运行构建脚本，记录成功/失败结果
   - 如果未找到构建命令，跳过并标记为“未配置构建”

## 第 7 阶段：评分与报告生成

从 `${CLAUDE_PLUGIN_ROOT}/skills/retro/references/eval-dimensions.md` 中加载评分标准。
如果插件根目录不可用，使用内置的权重：

**评分标准**：
- 效率（浪费百分比）：25%
- 稳定性（重启次数）：20%
- 符合标准的情况：20%
- 代码质量（测试通过率）：15%
- 提交规范遵循情况：5%
- 文档更新情况：5%
- 信号处理正确性：5%
- 总耗时：5%

在 `{project_root}/docs/retro/{date}-retro.md` 中生成报告：
**生成报告的代码示例：**（具体代码在 **CODE_BLOCK_3___diff** 中）

**评分指南（使用这些表情符号）**：
- 绿色 = 优秀
- 黄色 = 可接受
- 红色 = 需要关注

## 第 8 阶段：交互式修复建议

生成报告后：

1. **向用户展示总结**：总体评分、最常见的 3 个故障模式、3 个改进建议

2. **对于每个建议的修复方案**（如果有）：
   - 提问用户：“是否要将修复方案应用到 {file}？（附带简短描述）”
   - 提供选项：“应用” / “跳过” / “先查看差异”

3. **如果选择“先查看差异”**：显示完整差异，然后再询问用户是否应用

4. **如果用户选择“应用”**：使用编辑工具直接应用更改

5. **所有修复方案应用完成后**：
   - 如果有修复方案应用，建议使用 `fix(retro): {description}` 提交更改
   - 不要自动提交更改——仅提供提交建议

## 第 9 阶段：更新 CLAUDE.md

修复完成后，更新项目的 CLAUDE.md，使其保持简洁且对未来使用的代理有用。

### 步骤：

1. **读取 CLAUDE.md** 并检查文件大小：`wc -c CLAUDE.md`
2. **添加本次回顾的收获**：
   - 需要记住的管道故障模式（避免下次再次发生）
   - 新的工作流程规则或流程改进
   - 更新的命令或工具变更
   - 在管道运行过程中产生的架构决策
3. **如果文件长度超过 40,000 个字符**：
   - 将已完成的阶段/里程碑历史记录压缩为一行
   - 删除冗长的说明——保留简洁、可操作的笔记
   - 删除重复内容（在同一部分中重复说明的内容）
   - 删除过时的迁移说明、旧的调试信息
   - 删除代码中显而易见的示例或已在技能/文档文件中覆盖的内容
   - 删除已解决的问题的过时故障排查信息
4. **验证文件长度是否不超过 40,000 个字符**——如果仍超过，删除最不重要的内容
5. **编写更新后的 CLAUDE.md**，并更新“最后更新”日期

### 优先级（保留/删除规则）：

- **务必保留**：技术栈、目录结构、操作规范、常用命令、架构决策
- **保留**：工作流程说明、活跃问题的故障排查方法、关键文件引用
- **压缩**：阶段历史记录（每条记录占一行）、详细示例、工具/MCP 列表
- **优先删除**：历史记录、冗长的说明、重复内容、已解决的问题

### 规则：
- **切勿删除操作规范部分**——这些是重要的指导原则
- 保持整体的章节结构和顺序
- 每一行内容都必须有存在的必要性：“未来的代理是否需要这些信息？”
- 提交更新：`git add CLAUDE.md && git commit -m "docs: revise CLAUDE.md (post-retro)"`

## 第 10 阶段：评估整个系统

在评估完项目管道后，进一步评估整个系统——包括使用的技能、脚本和生成结果的管道逻辑。进行严格的自我评估。

### 评估内容：

1. **读取本次管道运行中调用的技能**（从 `pipeline.log` 的 `INVOKE` 行中获取）：
   - 对于每个技能：`${CLAUDE_PLUGIN_ROOT}/skills/{stage}/SKILL.md`
   - 该技能是否具备处理该项目需求所需的正确指令？
   - 是否遗漏了必要的上下文信息？

2. **查看 `solo-dev.sh` 中的信号处理和阶段逻辑**：
   - `${CLAUDE_PLUGIN_ROOT}/scripts/solo-dev.sh`
   - 是否存在结构上的问题（阶段顺序错误、缺少重新执行操作、修复操作失败等）？

3. **与第 3 阶段发现的故障模式进行对照**：
   - 对于每个故障：根本原因是在技能、脚本还是项目中？
   - 导致问题的技能即为系统缺陷

### 对整个系统进行评分（而非仅评估项目本身）：

**评分代码示例：**（具体代码在 **CODE_BLOCK_5___** 中）

### 思考系统优化

在完成系统评分后，进一步思考整个系统（包括 CLAUDE.md、文档、代码检查工具、技能等）的优化方向。思考以下问题：

1. **上下文支持**：代理在仓库中是否具备完成任务所需的所有资源？还是因为知识缺失、分散或过时而遇到困难？
   - 缺失的文档 → 添加到 `docs/` 或 CLAUDE.md 中
   - 过时的文档 → 记录下来以便后续整理
   - 仅存在于团队成员记忆中的知识 → 需要整理成文档

2. **架构限制**：代理是否违反了模块边界、产生了不一致的结果？或者忽略了某些规范？
   - 重复出现的错误 → 需要添加代码检查工具或规则
   - 不一致的模式 → 需要在 CLAUDE.md 中明确相应的最佳实践
   - 思考：如果未来有代理遇到类似问题，应该如何处理？

3. **技能需求**：哪些技能需要改进？哪些新技能是必要的？
   - 导致问题的技能 → 编写相应的 SKILL.md 修复方案
   - 缺乏的功能 → 提出新的技能需求，以便后续开发

将评估结果记录到 `~/.solo/evolution.md` 中（如果文件不存在则创建）：

**记录规则：**（具体代码在 **CODE_BLOCK_6___** 中）

**记录规则**：
- 诚实地评估问题——即使某个技能存在缺陷，也要如实说明
- 每个问题都必须有具体的解决方案（包括修改内容）
- 记录有效的做法——避免破坏现有的良好实践
- 保持记录的简洁性——该文件会随着时间不断更新

## 信号输出

**输出信号**：`<solo:done/>`

**重要提示**：`/retro` 总会输出 `<solo:done/>`——表示流程已完成，无需重新执行。

## 边缘情况处理：

- **没有 `pipeline.log`：** 显示错误信息并提示用户：“未找到管道日志。请先运行管道。”
- **`pipeline.log` 为空**：报告“管道日志为空——是否在迭代开始前就取消了管道？”
- **没有迭代日志**：跳过第 4 阶段的样本分析，并在报告中注明
- **没有 `plan-done` 文件**：跳过第 5 阶段的检查，并在报告中注明
- **没有测试/构建命令**：跳过第 6 阶段的检查，并在报告中注明
- **管道仍在运行**：警告用户：“虽然找到了状态文件，但管道可能仍在运行。请基于部分数据进行分析。”

## 参考文件：

- `${CLAUDE_PLUGIN_ROOT}/skills/retro/references/eval-dimensions.md` — 评分标准（8 个维度及权重）
- `${CLAUDE_PLUGIN_ROOT}/skills/retro/references/failure-catalog.md` — 已知的故障模式及对应的修复方案