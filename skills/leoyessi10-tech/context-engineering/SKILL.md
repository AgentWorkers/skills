---
name: context-compression
description: 当用户请求“压缩上下文”、“总结对话历史”、“实现数据压缩”、“减少令牌使用量”，或者提到上下文压缩、结构化总结、每任务所需的令牌数量优化，以及长时间运行的代理会话超出上下文限制时，应使用此技能。
---

# 上下文压缩策略

当代理会话生成数百万条对话历史记录时，压缩就变得必不可少。一种简单的做法是采用激进的压缩方式来减少每次请求所需的令牌数。但正确的优化目标应该是“每任务所需的令牌数”——即完成任务所消耗的总令牌数，这包括了在压缩过程中丢失关键信息时重新获取数据所需的成本。

## 何时启用该策略

在以下情况下启用该策略：
- 代理会话超出上下文窗口限制
- 代码库的令牌数超过上下文窗口限制（500万令牌以上）
- 设计对话摘要策略时
- 调试代理“忘记”它们修改了哪些文件的情况
- 构建用于评估压缩质量的框架时

## 核心概念

上下文压缩在节省令牌数和信息丢失之间进行权衡。目前有三种可用于生产环境的压缩方法：

1. **基于锚点的迭代摘要**：维护结构化、持久的摘要，其中包含会话意图、文件修改、决策和下一步操作的明确部分。当需要压缩时，仅总结新截断的部分，并将其与现有摘要合并。这种结构化方式通过为特定类型的信息分配专门的部分来确保信息的保留。

2. **不透明压缩**：生成优化了重建准确性的压缩表示。虽然可以达到最高的压缩比（99%以上），但会牺牲可解释性。无法验证哪些信息被保留了下来。

3. **再生型完整摘要**：在每次压缩时生成详细的结构化摘要。虽然可以生成可读的输出，但由于每次都是完全重新生成而非增量合并，因此在多次压缩后可能会丢失一些细节。

关键在于：结构化的方式有助于确保信息的保留。专门设置的部分起到了检查清单的作用，防止重要信息被遗漏。

## 详细主题

### 为什么“每任务所需的令牌数”很重要

传统的压缩指标关注的是每次请求所需的令牌数。这种优化方式是错误的。当压缩过程中丢失了文件路径或错误信息等关键细节时，代理必须重新获取数据，重新探索解决方案，从而浪费更多的令牌。

正确的指标应该是“每任务所需的令牌数”——即从任务开始到完成所消耗的总令牌数。一种压缩策略即使节省了0.5%的令牌数，但如果导致20%的重新获取数据成本增加，那么总体来说也是不划算的。

### “工件追踪”问题

在所有压缩方法中，“工件追踪”的完整性是最薄弱的环节，在评估中的得分仅为2.2-2.5分（满分5.0分）。即使是有明确文件部分的结构化摘要也难以在长时间的会话中保持对所有文件的完整追踪。

编码代理需要知道：
- 创建了哪些文件
- 哪些文件被修改了以及修改了什么
- 哪些文件被读取但未被修改
- 函数名称、变量名称、错误信息

这个问题可能需要专门的处理方式，而不仅仅是简单的摘要功能：例如，需要一个独立的工件索引或在代理框架中明确记录文件状态。

### 结构化摘要部分

有效的结构化摘要应包含以下明确的部分：

```markdown
## Session Intent
[What the user is trying to accomplish]

## Files Modified
- auth.controller.ts: Fixed JWT token generation
- config/redis.ts: Updated connection pooling
- tests/auth.test.ts: Added mock setup for new config

## Decisions Made
- Using Redis connection pool instead of per-request connections
- Retry logic with exponential backoff for transient failures

## Current State
- 14 tests passing, 2 failing
- Remaining: mock setup for session service tests

## Next Steps
1. Fix remaining test failures
2. Run full test suite
3. Update documentation
```

这种结构可以防止文件路径或决策等重要信息的丢失，因为每个部分都必须被明确地记录下来。

### 压缩触发策略

触发压缩的时机与压缩方式同样重要：

| 方法 | 触发点 | 权衡 |
|----------|---------------|-----------|
| 固定阈值 | 当上下文利用率达到70-80%时 | 方法简单，但可能会过早压缩 |
| 滑动窗口 | 保留最后N条记录和摘要 | 可预测的上下文大小 |
| 基于重要性的压缩 | 先压缩不相关的部分 | 方法复杂，但能保留关键信息 |
| 任务边界压缩 | 在任务逻辑完成时压缩 | 摘要清晰，但时间点难以预测 |

对于大多数编码代理的应用场景来说，结合结构化摘要的滑动窗口方法在可预测性和质量之间提供了最佳的平衡。

### 基于探针的评估

传统的评估指标（如ROUGE或嵌入相似度）无法准确衡量压缩的质量。一个摘要可能在词汇重叠方面得分很高，但却可能忽略了代理实际需要的文件路径信息。

基于探针的评估方法通过在压缩后提出问题来直接衡量功能质量：

| 探针类型 | 测量内容 | 示例问题 |
|------------|---------------|------------------|
| 回忆 | 事实保留 | “原始的错误信息是什么？” |
| 工件追踪 | 文件追踪 | “我们修改了哪些文件？” |
| 继续性 | 任务规划 | “我们接下来应该做什么？” |
| 决策 | 推理链 | “我们对Redis问题做出了什么决定？” |

如果压缩正确地保留了信息，代理就能给出正确的答案；否则，代理可能会做出错误的猜测。

### 评估维度

有六个维度可以用来评估编码代理的压缩质量：
1. **准确性**：技术细节是否正确？例如文件路径、函数名称、错误代码。
2. **上下文意识**：响应是否反映了当前的对话状态？
3. **工件追踪**：代理是否知道哪些文件被读取或修改了？
4. **完整性**：响应是否回答了问题的所有部分？
5. **连续性**：工作是否可以在不重新获取数据的情况下继续进行？
6. **指令遵循**：响应是否遵循了既定的约束？

不同压缩方法在准确性方面的差异最大（相差0.6分）。工件追踪的完整性普遍较差（得分在2.2-2.5分之间）。

## 实用指南

### 三阶段压缩工作流程

对于代码库庞大或超出上下文窗口限制的代理系统，可以通过以下三个阶段来应用压缩：
1. **研究阶段**：根据架构图、文档和关键接口生成研究文档。将组件和依赖关系的分析结果压缩成结构化的文档。输出：一份研究文档。
2. **规划阶段**：将研究结果转化为实现规范，包括函数签名、类型定义和数据流。一个包含500万令牌的代码库可以压缩成大约2000字的规范文档。
3. **实施阶段**：根据规范进行实现。此时，上下文的关注点应放在规范上，而不是原始的代码库上。

### 使用示例工件作为参考

当提供手动迁移示例或参考性拉取请求（PR）时，可以将其作为模板来理解目标模式。这些示例可以揭示静态分析无法发现的问题：哪些不变量必须保持不变，哪些服务在修改后会出现问题，以及一个干净的迁移应该是什么样的。

这一点在代理无法区分本质复杂性（业务需求）和偶然复杂性（遗留的解决方案）时尤为重要。示例工件能够明确这种区别。

### 实现基于锚点的迭代摘要

1. 定义符合你的代理需求的具体摘要部分。
2. 在第一次压缩时，将截断的历史记录总结为相应的部分。
3. 在后续的压缩中，仅总结新截断的内容。
4. 将新的摘要合并到现有部分中，而不是重新生成整个摘要。
5. 记录哪些信息来自哪个压缩周期，以便于调试。

### 各种方法的适用场景

- **使用基于锚点的迭代摘要**：
  - 会话持续时间较长（100条以上消息）
  - 文件追踪非常重要（如编码、调试）
  - 需要验证哪些信息被保留

- **使用不透明压缩**：
  - 需要最大程度地节省令牌数
  - 会话相对较短
  - 重新获取数据的成本较低

- **使用再生型摘要**：
  - 摘要的可解释性至关重要
  - 会话有明确的阶段边界
  - 每次压缩后都可以进行完整的上下文审查

### 压缩比考虑因素

| 方法 | 压缩比 | 质量得分 | 权衡 |
|--------|-------------------|---------------|-----------|
| 基于锚点的迭代摘要 | 98.6% | 3.70 | 质量最高，但压缩程度稍低 |
| 再生型摘要 | 98.7% | 3.44 | 质量良好，压缩程度适中 |
| 不透明压缩 | 99.3% | 压缩程度最高，但质量略有损失 |

结构化摘要多保留的0.7%令牌数可以提升0.35分的质量。对于任何重新获取数据成本重要的任务来说，这种权衡方式都是更有利的。

## 示例

**示例1：调试会话的压缩**

原始上下文（89,000条令牌，178条消息）：
- 在/api/auth/login端点出现了401错误
- 问题追溯到了认证控制器、中间件和会话存储
- 发现Redis连接已失效
- 修复了连接池问题，并添加了重试逻辑
- 14个测试通过，2个失败

压缩后的结构化摘要：

```markdown
## Session Intent
Debug 401 Unauthorized error on /api/auth/login despite valid credentials.

## Root Cause
Stale Redis connection in session store. JWT generated correctly but session could not be persisted.

## Files Modified
- auth.controller.ts: No changes (read only)
- middleware/cors.ts: No changes (examined)
- config/redis.ts: Fixed connection pooling configuration
- services/session.service.ts: Added retry logic for transient failures
- tests/auth.test.ts: Updated mock setup

## Test Status
14 passing, 2 failing (mock setup issues)

## Next Steps
1. Fix remaining test failures (mock session service)
2. Run full test suite
3. Deploy to staging
```

**示例2：基于探针的评估**

压缩后，询问“原始的错误信息是什么？”

好的回答（使用结构化摘要）：
> “原始的错误是来自/api/auth/login端点的401 Unauthorized响应。用户使用有效的凭据时遇到了这个错误。根本原因是会话存储中的Redis连接失效。”

差的回答（使用激进压缩）：
> “我们正在调试一个认证问题。登录失败了。我们修复了一些配置问题。”

结构化的回答保留了端点、错误代码和根本原因。而激进的压缩方式则丢失了所有技术细节。

## 指导原则

1. 优化目标是“每任务所需的令牌数”，而不是每次请求所需的令牌数。
2. 使用包含文件追踪部分的结构化摘要。
3. 在上下文利用率达到70-80%时触发压缩。
4. 采用增量合并的方式，而不是完全重新生成摘要。
5. 通过基于探针的评估来测试压缩质量。
6. 如果文件追踪非常重要，需要单独记录工件追踪信息。
7. 为了更好的质量保留，可以接受稍低的压缩比。
8. 监控重新获取数据的频率作为压缩质量的指标。

## 集成

该策略与其他几个技能紧密相关：
- **上下文退化**：压缩是一种缓解上下文退化的策略。
- **上下文优化**：压缩是众多优化技术之一。
- **评估**：基于探针的评估方法适用于压缩质量的测试。
- **内存系统**：压缩与临时存储和摘要内存的使用模式有关。

## 参考资料

内部参考：
- [评估框架参考](./references/evaluation-framework.md) - 详细的探针类型和评分标准

本集合中的相关技能：
- **上下文退化**：了解压缩可以防止哪些问题。
- **上下文优化**：更广泛的优化策略。
- **评估**：构建评估框架的方法。

外部资源：
- Factory Research：《评估AI代理的上下文压缩效果》（2025年12月）
- Zheng等人关于LLM作为评估工具的研究（2023年）
- Netflix工程：《无限的软件危机》——大规模的三阶段工作流程和上下文压缩（2025年AI峰会）

---

## 技能元数据

**创建时间**：2025-12-22
**最后更新时间**：2025-12-26
**作者**：Context Engineering团队的成员
**版本**：1.1.0