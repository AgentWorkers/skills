---
name: agent-estimation
description: **使用AI代理自身的操作单位（工具调用次数）来准确估算其工作量**，而非以人类工作时间来衡量。当需要估算、规划或评估某个编码任务所需时间时，该方法尤为适用。这样可以避免常见的错误——即代理团队过于依赖人类开发者的时间表，从而导致严重的高估。输出结果包含详细的拆分数据（如工具调用次数）、风险因素以及最终的耗时估算（以实际运行时间表示）。
---
# 代理任务估算技能

## 问题

AI编码代理系统性地高估任务耗时，因为它们依赖于从训练数据中学习到的开发者时间线。一个代理可以在30分钟内完成的任务，可能会被估算为“2-3天”，因为这是开发者论坛帖子中提到的时间。

## 解决方案

强制代理使用自己的工作单位（**工具调用轮次**）来进行估算，并且只在最后将结果转换为人类实际工作时间。

## 核心单位

| 单位 | 定义 | 规模 |
|------|-----------|-------|
| **轮次** | 一个工具调用周期：思考 → 编写代码 → 执行 → 验证 → 修复 | 约2-4分钟 |
| **模块** | 由多个轮次构建而成的功能单元 | 2-15轮次 |
| **项目** | 所有模块 + 集成 + 调试 | 模块总和 × 集成系数 |

**轮次**是基本的工作单位，它直接对应于以下步骤：
1. 代理决定要做什么
2. 代理编写/编辑代码
3. 代理运行代码或测试
4. 代理读取输出结果
5. 代理判断是否需要修复（如果是，则进入下一轮）

## 估算流程

当被要求估算任务时，请按照以下步骤进行：

### 第一步：分解为模块

将任务分解为功能模块。每个模块都应该能够独立构建和测试。问自己：“我可以一次构建哪些独立的模块？”

### 第二步：估算每个模块所需的轮次数

对于每个模块，根据以下标准估算所需的轮次数：

| 类型 | 典型轮次数 | 例子 |
|---------|---------------|----------|
| **样板代码/已知模式** | 1-2轮 | CRUD接口、配置文件、标准API客户端 |
| **中等复杂度** | 3-5轮 | 自定义用户界面布局、状态管理、数据管道 |
| **探索性/文档不足** | 5-10轮 | 不熟悉的框架、特定平台的API、复杂的集成 |
| **高不确定性** | 8-15轮 | 未记录的行为、新颖的算法、多系统调试 |

关键的校准规则：
- 如果你可以一次性生成代码并且代码能够正常运行 → **1轮**
- 如果你需要生成代码、运行代码、发现错误并修复 → **2-3轮**
- 如果库/框架的文档很少，你需要自行猜测 → **5轮以上**
- 如果涉及平台权限、操作系统级别的API或用户需要手动验证的环境特定行为 → 额外增加**2-3轮**

### 第三步：分配风险系数

每个模块都会被分配一个风险系数，以调整其所需的轮次数：

| 风险等级 | 系数 | 适用情况 |
|------------|------------|---------------|
| **低** | 1.0 | 生态系统成熟、文档齐全、代理能够找到合适的模式 |
| **中等** | 1.3 | 存在一些未知因素，可能需要额外1-2轮调试 |
| **高** | 1.5 | 文档匮乏、存在平台特性问题、集成环节存在未知风险 |
| **非常高** | 2.0 | 可能遇到死胡同，可能需要完全改变方法 |

### 第四步：计算总轮次数

```
Module effective rounds = base rounds × risk coefficient
Project rounds = Σ(module effective rounds) + integration rounds
Integration rounds = 10-20% of base total (for wiring modules together)
```

### 第五步：转换为人类实际工作时间

只有在最后一步，才将轮次数转换为人类实际工作时间：

```
Wallclock time = project rounds × minutes_per_round
```

默认的 `minutes_per_round` 值为 **3分钟**（包括代理的编写时间和用户的审核时间）。

根据具体情况调整该参数：
- 如果迭代速度快，用户几乎不进行审核 → 每轮2分钟
- 如果领域复杂，用户会仔细审核每个步骤 → 每轮4分钟
- 如果用户需要手动进行测试（例如涉及移动设备、硬件或权限设置） → 每轮5分钟

## 输出格式

估算结果必须按照以下格式输出：

```markdown
### Task: [task name]

#### Module Breakdown

| # | Module | Base Rounds | Risk | Effective Rounds | Notes |
|---|--------|------------|------|-----------------|-------|
| 1 | ...    | N          | 1.x  | M               | why   |
| 2 | ...    | N          | 1.x  | M               | why   |

#### Summary

- **Base rounds**: X
- **Integration**: +Y rounds
- **Risk-adjusted total**: Z rounds
- **Estimated wallclock**: A – B minutes (at N min/round)

#### Biggest Risks
1. [specific risk and what could blow up the estimate]
2. [...]
```

## 需要避免的错误模式

这些错误模式正是该技能存在的目的，用于防止它们发生：
1. **依赖人类工作时间估算**：“开发者通常需要大约2周时间...” → 不要这样做。应该从轮次数开始估算。
2. **无根据地增加时间**：仅仅为了“保险”而随意增加时间，而不考虑实际风险 → 不要这样做。应该使用风险系数来评估。
3. **将复杂度与代码行数混淆**：500行的样板代码并不一定复杂；一行CGEvent API代码也不一定容易处理。应该根据任务的不确定性来估算，而不是代码行数。
4. **忽略集成成本**：虽然各个模块可以独立工作，但它们在集成时可能会出现问题。务必加上集成所需的轮次。
5. **忽略用户端的瓶颈**：如果用户需要手动授权、重启应用程序或在特定设备上进行测试，这些都会增加额外的时间。请根据实际情况调整 `minutes_per_round`，不要无根据地增加轮次数。

## 校准参考

以下是一些已知轮次数量的示例项目，可以帮助你进行校准：

详细的项目类型示例请参考 `references/calibration-examples.md`。

## 评估提示

请参考 `evals/evals.json` 中的测试用例来验证估算的准确性。