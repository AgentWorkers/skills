---
name: jb-simplify
description: **简化 Juicebox 项目设计的检查清单：通过利用原生协议机制减少自定义合约的使用**
---

# Juicebox V5 简化检查清单

在编写自定义合约之前，请先查看此清单，以寻找更简单的解决方案。

## 简化原则

> **优先选择原生机制 > 市售钩子 > 自定义钩子 > 自定义合约**

尽可能避免使用更高层次的抽象：
- 降低部署成本
- 减少攻击面
- 提高用户界面的兼容性
- 使项目更易于审计

---

## 实施前的检查清单

### 1. 是否需要自定义支付钩子？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 支付时铸造 NFT | 直接使用 `nana-721-hook-v5` |
| 如果从 DEX 购买代币更便宜 | 直接使用 `nana-buyback-hook-v5` |
| 限制付款者 | 使用链下白名单或支付元数据 |
| 不同层级使用不同代币 | 使用具有不同价格的 721 钩子层级 |
| 设置单次付款上限 | 仔细考虑是否真的需要 |

**只有在以下情况下才编写自定义支付钩子**：你需要修改现有钩子无法处理的支付记录逻辑。

---

### 2. 是否需要自定义提现钩子？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 通过燃烧 NFT 来兑现 | 使用 `nana-721-hook-v5`（它已经实现了这一功能） |
| 按比例从项目剩余资金中兑现 | 将 `cashOutTaxRate` 设置为 0（原生行为） |
| 部分兑现（基于债券曲线） | 将 `cashOutTaxRate` 设置为所需值 |
| 带有时限的兑现 | 使用 `pauseCashOut: true` 的规则集，并将规则集放入队列中 |
| 通过外部池进行兑现 | 这可能需要自定义钩子 |

**只有在以下情况下才编写自定义提现钩子**：兑现金额必须来自项目之外的资金。

---

### 3. 是否需要自定义分配钩子？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 将代币发送到多个地址 | 使用多个分配规则，指定直接受益人 |
| 将代币发送到其他 JB 项目 | 在分配规则中设置 `projectId` |
| 将代币添加到项目余额中而不是直接支付 | 将 `preferAddToBalance` 设置为 `true` |
| 限制领取者 | 将受益人设置为多签名地址或合约 |
| 在转发前转换代币 | **需要自定义分配钩子** |
| 将代币添加到 LP 位置 | **需要自定义分配钩子** |

**只有在以下情况下才编写自定义分配钩子**：你需要转换代币或与外部协议进行交互。

---

### 4. 是否需要多个排队规则集？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 每月分配 | 使用一个规则集，并设置 `duration: 30 days` |
| 增加/减少代币发行量 | 使用 `weightCutPercent` 自动调整发行量 |
| 随时间变化的不同阶段 | 只对实际发生变化的部分排队规则集 |
| 分12个月逐步释放代币 | 使用一个循环规则集，而不是12个排队规则集 |

**只有在配置在不同阶段发生变化时才排队多个规则集**。

---

### 5. 是否需要自定义 NFT 逻辑？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 支付时铸造 NFT | 直接使用 `nana-721-hook-v5` |
| 不同层级设置不同价格 | 在 721 钩子中配置层级 |
| 每层使用静态艺术作品 | 在层级配置中使用 `encodedIPFSUri` |
| 动态/生成型艺术作品 | 仅实现 `IJB721TokenUriResolver` |
| 可组合/分层的 NFT | 仅实现 `IJB721TokenUriResolver` |
| 在链上使用 SVG | 仅实现 `IJB721TokenUriResolver` |
| 需要自定义铸造逻辑 | 这可能需要自定义钩子 |

**只有在需要修改 721 钩子处理支付方式时才编写自定义支付/数据钩子**。对于自定义内容，可以使用解析器接口。

**参考**：[banny-retail-v5](https://github.com/mejango/banny-retail-v5) 仅使用自定义解析器实现了可组合的 NFT。

---

### 5b. 何时需要扩展 721 钩子？

当你需要修改 **资金管理机制**（而不仅仅是内容）时，扩展 721 钩子是必要的：

| 需要的功能 | 需要自定义委托的原因 |
|---------------|------------------------------|
| 动态的提现权重 | 兑现金额根据结果变化 |
| 追踪首代所有者 | 奖励归原始铸造者所有，而非当前持有者 |
| 基于阶段的限制 | 不同游戏阶段有不同的规则 |
| 对结果的链上治理 | 通过计分卡投票来决定奖励分配 |

**参考**：[defifa-collection-deployer-v5](https://github.com/BallKidz/defifa-collection-deployer-v5) 展示了使用动态权重的预测游戏。

---

### 6. 是否真的需要自定义合约？

| 需要的功能 | 更简单的解决方案 |
|---------------|------------------|
| 分配代币 | 使用分配限制和循环规则集 |
| 资金管理 | 使用项目剩余资金 |
| NFT 控制的资金管理 | 使用 721 钩子和原生提现功能 |
| 不可变的配置 | 将所有权转移至燃烧地址 |
| 多签名控制 | 将所有者设置为安全地址或多签名地址 |
| 治理 | 使用现有的治理框架 |

---

## 简化相关问题

按顺序回答这些问题。遇到第一个“是”就停止：

### 对于支付
1. 721 钩子能处理这个问题吗？ → **使用 721 钩子**
2. 回购钩子能处理这个问题吗？ → **使用回购钩子**
3. 支付元数据和链下逻辑能处理这个问题吗？ → **使用原生支付功能**
4. → 考虑使用自定义支付钩子

### 对于兑现
1. 只是燃烧多余的 NFT 吗？ → **使用 721 钩子**
2. 只是兑换多余的代币吗？ → **使用带税率的原生提现功能**
3. 价值来自项目剩余资金吗？ → **使用原生提现功能**
4. → 考虑使用自定义提现钩子

### 对于分配
1. 收益者只是地址吗？ → **使用原生分配规则**
2. 收益者是其他 JB 项目吗？ → **使用带有 `projectId` 的分配规则**
3. 需要转换代币吗？ → **使用分配钩子**
4. → 考虑使用自定义分配钩子

### 对于基于时间的逻辑
1. 是定期重复执行的吗？ → **使用循环规则集**
2. 是一次性调整计划吗？ → **将规则集放入队列中**
3. 是否依赖于外部事件？ → **考虑使用审批钩子**
4. → 考虑使用自定义逻辑

### 对于 NFT 内容
1. 每层的艺术作品是静态的吗？ → **在层级配置中使用 `encodedIPFSUri`**
2. 需要动态/生成型艺术作品吗？ → **实现 `IJB721TokenUriResolver`**
3. 需要可组合的 NFT 吗？ → **实现 `IJB721TokenUriResolver`**
4. 需要修改铸造逻辑吗？ → 考虑包装 721 钩子

### 对于游戏/预测
1. 每层的兑现金额是固定的吗？ → **使用标准的 721 钩子**
2. 结果决定了奖励分配吗？ → **扩展 721 钩子（Defifa 模式）**
3. 需要在链上进行结果投票吗？ → **添加治理合约**
4. 奖励只归原始铸造者吗？ → **在委托中追踪首代所有者**

---

## 常见的过度设计错误

### 错误 1：包装 721 钩子

```
❌ WRONG: Create DataHookWrapper that delegates to 721 hook
✅ RIGHT: Use 721 hook directly, achieve goals via ruleset config
```

### 错误 2：使用自定义分配钩子进行代币分配

```
❌ WRONG: VestingSplitHook that holds funds and releases over time
✅ RIGHT: Payout limits reset each cycle, achieving the same result
```

### 错误 3：为 12 个月的代币分配设置 12 个排队规则集

```
❌ WRONG: Queue 12 identical rulesets with different start times
✅ RIGHT: One ruleset with duration: 30 days that cycles automatically
```

### 错误 4：对于简单的转发操作使用自定义分配钩子

```
❌ WRONG: Split hook that just forwards ETH to an address
✅ RIGHT: Set the address as the split beneficiary directly
```

### 错误 5：自定义兑现逻辑

```
❌ WRONG: Custom hook calculating pro-rata share of surplus
✅ RIGHT: cashOutTaxRate: 0 gives linear redemption natively
```

### 错误 6：为 NFT 艺术作品编写自定义钩子

```
❌ WRONG: Write custom pay hook to generate dynamic NFT metadata
✅ RIGHT: Use 721 hook + custom IJB721TokenUriResolver for content only
```

---

## 复杂性成本表

| 解决方案 | 气体成本 | 审计风险 | 用户界面支持 |
|----------|----------|------------|------------|
| 仅使用原生配置 | 最低 | 最低 | 完全支持 |
| 市售钩子 | 低 | 低 | 完全支持 |
| 自定义代币 URI 解析器 | 低 | 低 | 完全支持 |
| 自定义分配钩子 | 中等 | 中等 | 部分支持 |
| 自定义支付钩子 | 中等 | 中等 | 部分支持 |
| 扩展的 721 钩子委托 | 中等-高 | 中等-高 | 需要自定义用户界面 |
| 自定义提现钩子 | 高 | 高 | 支持有限 |
| 完全自定义的系统 | 最高 | 最高 | 不支持 |

### 何时需要更高的复杂性

并非所有的复杂性都是坏事。在以下情况下，扩展钩子是合理的：

| 模式 | 理由 |
|---------|---------------|
| 预测游戏（Defifa） | 动态权重无法通过其他方式实现 |
| 可组合的 NFT（Banny） | 仅使用解析器可以保持资金管理机制的标准 |
| 基于阶段的游戏 | 规则集 + 自定义委托比其他方式更简洁 |

**关键提示**：仅针对 **资金管理机制** 扩展钩子，对于 **内容** 仅使用解析器。

---

## 最终检查清单

在最终确定设计之前，请验证以下内容：
- 如果有直接受益人的情况，**不需要** 自定义钩子
- 如果可以使用多个原生分配规则，**不需要** 自定义分配钩子
- 如果可以直接使用钩子，**不需要** 包装数据的钩子
- 如果一个循环规则集可以满足需求，**不需要** 多个排队规则集
- 如果分配限制有效，**不需要** 自定义分配逻辑
- 如果项目剩余资金足够，**不需要** 自定义资金管理逻辑
- 如果原生提现功能可用，**不需要** 自定义提现钩子
- 如果 IJB721TokenUriResolver 可以满足内容需求，**不需要** 自定义支付钩子

如果所有选项都符合要求，那么你可以确信确实需要编写自定义代码。

---

## 相关技能

- `/jb-patterns` - 常见的设计模式及示例
- `/jb-project` - 项目部署
- `/jb-pay-hook` - 当你需要自定义支付钩子时
- `/jb-cash-out-hook` - 当你需要自定义提现钩子时
- `/jb-split-hook` - 当你需要自定义分配钩子时