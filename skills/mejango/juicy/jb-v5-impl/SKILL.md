---
name: jb-v5-impl
description: 关于Juicebox V5协议的深入实现知识。涵盖了其内部工作机制、边缘情况、权衡因素、Gas机制（用于控制资源消耗）以及关键的集成模式。在分析系统内部运作原理时非常有用。
---

# Juicebox V5 实现深度解析

本文档为集成者提供了关于 Juicebox V5 的深入实现细节，涵盖了内部机制、边缘情况、权衡因素以及关键考虑事项。

---

## 支付流程内部机制

### JBMultiTerminal.pay() 的执行过程

---

### 关键实现细节

**权重计算**：代币的铸造使用 18 位小数的定点数学运算：
**权重** 是规则集中配置的每单位货币的代币数量。

**数据钩子覆盖**：当 `useDataHookForPay` 为 true 时，数据钩子可以：
- 返回修改后的权重（影响代币数量）
- 指定接收转接资金的支付钩子
- 向支付钩子传递自定义元数据

**钩子执行顺序**：支付钩子在代币铸造后依次执行。每个钩子会从支付中接收其指定的金额。

### 边缘情况

1. **权重为零**：虽然未铸造代币，但仍然接受支付
2. **数据钩子回退**：整个支付流程回退
3. **支付钩子回退**：整个支付流程回退（不执行部分操作）
4. **返回的代币数量不足**：在所有操作完成后回退（导致Gas浪费）

### Gas 考虑因素

- 单次支付（无钩子使用）：约 150,000 Gas
- 使用数据钩子时：根据钩子的复杂性，额外消耗 50,000-100,000 Gas
- 每个支付钩子：根据钩子的逻辑消耗不同的 Gas
- 解码元数据每 32 字节额外消耗约 5,000 Gas

---

## 现金提取（赎回）机制

### 债券曲线公式

现金提取的计算采用了修改后的债券曲线模型：

---

**税率的影响**

| 税率 | 影响 |
|----------|--------|
| 0% | 线性赎回：按比例获取剩余资金 |
| 50% | 部分惩罚：较高额度的赎回会受到更多惩罚 |
| 100% | 无法赎回：返回 0 |

**关键点**：税率决定了以下情况：
- 小额赎回更接近实际价值
- 大额赎回（相对于总供应量）会受到更多惩罚
- 当税率为 100% 时，剩余资金将被永久锁定

### 剩余资金计算

剩余资金的计算方式如下：

**`useTotalSurplusForCashOuts` 元数据标志** 决定了是使用：
- **终端剩余资金**：仅限于该终端的余额减去其支付限额
- **总剩余资金**：汇总所有项目的剩余资金

**权衡**：使用总剩余资金可以提供更准确的估值，但由于需要查询多个终端，因此会消耗更多 Gas。

### 边缘情况

1. **剩余资金为零**：无论代币数量多少，都无法提取资金
2. **税率为 100%**：返回 0，代币会被销毁
3. **提取的代币数量超过总供应量**：整个流程回退
4. **提取操作暂停**：通过规则集检查来暂停提取操作

---

## 规则集转换机制

### 审批钩子流程

---

**JBDeadline 实现**：要求在排队时间和规则集开始之间有 `DURATION()` 秒的时间间隔。如果排队太晚，审批将失败。

### 权重削减算法

权重在每个周期内呈指数级减少：
---

**优化**：对于周期数较多的情况（>1000），合约使用缓存的中间值来避免 O(n) 的计算开销：

---

## 规则集继承机制

当规则集被排队时：
1. 它会继承当前（或最新批准的）规则集的设置
2. 只有更改的参数才会覆盖继承的值
3. `basedOnId` 字段用于追踪继承链

**关键考虑**：如果审批钩子拒绝了规则集，系统会沿着继承链回溯，找到最新批准的规则集。

## 周期编号的生成方式

对于 `duration = 0`（无限期）的规则集，周期编号保持为 1。

---

## 预留代币的分配机制

### 积累模型

预留代币不会立即铸造。相反，它们会累积，直到调用 `sendReservedTokensToSplitsOf()` 时才会被分配：

---

### 分配流程

---

## 权衡因素

**批量分配**：
- 优点：Gas 使用效率较高（一次操作即可完成）
- 缺点：接收者需要等待手动触发
- 缺点：大量积累可能导致 Gas 限制

**每次支付分配**（另一种模式）：
- 优点：可以立即分配
- 缺点：每次支付的 Gas 成本较高

---

## Splits 系统细节

### 存储优化

为了提高 Gas 使用效率，Splits 使用打包存储方式：

---

### 锁定状态的 Splits 行为

在更新 splits 时：
1. 必须包含所有当前锁定的 splits
2. 锁定期限只能延长，不能缩短
3. 锁定状态的 splits 的其他属性不能更改

**边缘情况**：如果被锁定的 splits 的接收者变成了无法接收资金的合约，这些资金将一直被锁定，直到锁定期限结束。

### Split 的执行

---

## 买回钩子的决策逻辑

### 铸造与交换的比较

---

### TWAP 计算

1. 从 Uniswap 池中获取最新的数据
2. 如果观察窗口小于配置的 TWAP 窗口，使用可用的数据
3. 计算窗口内的算术平均值
4. 将价格波动转换为价格报价
5. 根据交换规模和池子的流动性调整滑动容忍度

### 滑动容忍度分级

---

## 失败处理

---

**关键点**：失败的交换不会导致整个支付流程回退。钩子会优雅地回退到标准铸造模式。

## 剩余资金的处理

交换执行后：

---

## 721 钩子的实现机制

### 支付处理流程

---

### 信用系统

---

**权衡**：信用系统提供了灵活性，但：
- 会因四舍五入产生微小费用
- 信用不能提取，只能用于 NFT
- 如果钩子被更改，信用将丢失

### 现金提取的权重计算

每个 NFT 的现金提取价值等于其对应的层级价格：

---

**费用机制**

### 费用计算

---

**注意**：费用是按照总金额的一定比例计算的，而不是额外添加的。

### 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**：
- 项目间的支付
- 注册在 JBFeelessAddresses 的地址
- 内部转账

### 保留的费用

当规则集元数据中的 `holdFees` 为 true 时：

---

## 集成建议

### 对于支付集成者

1. **始终设置合理的 `minReturnedTokens` 值**，以防止抢先交易
2. 在估算交易成本时考虑数据钩子的 Gas 成本
3. 在用户界面中优雅地处理支付钩子的回退情况
4. 验证元数据编码是否符合钩子的预期

### 对于钩子开发者

1. **保持 `beforePayRecordedWith()` 的只读和轻量级** —— 它会在每次支付时执行
2. 在 `afterPayRecordedWith()` 中优雅地处理失败情况，不要锁定用户的资金
3. 验证 `msg.sender` 是否是授权的终端
4. 考虑重入机制 —— 钩子在执行前会接收资金

### 对于项目运营者

1. **锁定关键的 splits**，以防止资金流失
2. 对于需要治理控制的项目，使用审批钩子
3. 定期分配预留的代币
4. 设置适当的支付限额，以控制风险

### Gas 优化技巧

1. **尽可能批量操作**（批量排队多个规则集）
2. 对于 721 钩子，使用信用而非直接支付
3. 在 Gas 较低的时候分配预留代币
4. 在分配剩余资金时考虑总剩余资金和终端剩余资金之间的权衡

---

## 常见问题

1. **将 `minReturnedTokens` 设置为 0**：容易受到中间人攻击
2. **忘记包含锁定的 splits**：会导致交易回退
3. **假设预留代币会立即分配**：代币会不断累积
4. **没有正确处理钩子元数据**：可能导致默默失败或交易回退
5. **忽略审批钩子的延迟**：如果排队太晚，规则集会被拒绝
6. **低估多钩子支付的 Gas 成本**：会导致交易失败
7. **在现金提取前没有验证剩余资金的存在**：会导致 Gas 的浪费

---

## 核心基础设施合约

### JBDirectory

该目录负责管理项目的终端和控制器分配。

#### 存储架构

---

#### 终端管理

`setTerminalsOf()` 会替换整个终端数组：
- 通过嵌套循环验证是否存在重复项
- 需要 `SET_TERMINALS` 权限，或者调用者必须是项目控制器
- 检查规则集的 `setTerminalsAllowed` 标志（如果控制器是调用者，则可以忽略此检查）

**primaryTerminalOf()** 的实现：
1. 如果设置了主要的终端，则返回该终端
2. 否则，返回第一个接受该代币的终端
3. 如果没有找到合适的终端，则返回空地址

#### 控制器迁移

`setControllerOf()` 负责处理控制器迁移：
1. 需要 `SET_controller` 权限，或者是通过允许列表首次设置的控制器
2. 检查规则集的 `setControllerAllowed` 标志
3. 如果旧控制器支持该接口，调用 `IJBMigratable.migrate()`

**关键点**：第一个控制器只能由 `isAllowedToSetFirstController` 允许列表中的地址设置

---

### JBProjects

ERC-721 合约，每个代币代表一个 Juicebox 项目。

#### 项目创建

`count` 变量同时用作项目总数计数器和下一个项目的 ID。

#### 元数据解析

---

**优雅降级**：如果没有设置解析器，返回空字符串，以防止交易回退。

#### ERC-2771 支持

覆盖 `_msgSender()`、`_msgData()` 和 `_contextSuffixLength()`，以支持通过可信转发器进行元交易。

---

### JBPermissions

基于位图的权限系统，支持细粒度的访问控制。

#### 存储架构

---

`uint256` 中的每个位代表 256 种可能的权限之一。项目 ID `0` 是通配符，允许访问所有项目的权限。

#### 权限检查

**hasPermission()** 实现了分层权限检查：

---

**hasPermissions()**（批量检查）：
- 如果存在 ROOT 权限，则立即返回 true
- 遍历所有请求的权限
- 如果缺少任何权限，则返回 false

#### setPermissionsFor() 中的安全限制

---

**边缘情况**：
- 权限 ID 0 是保留的，不能被设置
- 权限 ID 大于 255 会导致 `PermissionIdOutOfBoundsException`
- 空的权限数组是有效的（会清除所有权限）

---

### JBTokens

JBTokens 系统支持双重余额机制，同时支持未领取的信用和 ERC-20 代币。

#### 存储设计

---

#### 铸造逻辑

`mintFor()` 根据 ERC-20 的存在情况进行选择：

---

#### 烧毁逻辑

**burnFrom()** 先销毁信用，然后再销毁代币：

---

#### ERC-20 的部署

`deployERC20For()` 使用最小的代理克隆：
---

#### 自定义 ERC20 代币的集成

JBTokens 系统支持自定义 ERC20 代币，从而实现更高级的代币经济机制，同时保留 Juicebox 的支付和赎回机制。

#### 自定义代币的工作原理

当使用 `setTokenFor()` 配置自定义代币时：

---

**关键点**：设置自定义代币不会迁移现有的信用。信用持有者必须调用 `claimTokensFor()` 将信用转换为 ERC20 代币。

#### 自定义代币的铸造/销毁流程

接收支付时：

---

**现金提取时**：

---

**关键点**：控制器在调用 `processSplitWith()` 之前会优先接收资金。恶意钩子可能会窃取资金。

---

## 721 钩子的决策逻辑

### 铸造与交换的比较

---

### TWAP 计算

---

### 失败处理

---

**关键点**：失败的交换不会导致整个支付流程回退。钩子会优雅地回退到标准铸造模式。

---

## 剩余资金的处理

交换执行后：

---

## 721 钩子的层级机制

### 支付处理流程

---

### 信用系统

---

**权衡**：信用系统提供了灵活性，但：
- 会因四舍五入产生微小费用
- 信用不能提取，只能用于 NFT
- 如果钩子被更改，信用将丢失

### 现金提取的权重计算

每个 NFT 的现金提取价值等于其对应的层级价格：

---

**totalCashOutWeight()` 函数汇总所有未偿还的 NFT 价值，用于计算比例。

**关键点**：如果 NFT 价格波动较大，低价 NFT 的持有者获得的现金提取比例会相应减少。

---

## 费用机制

### 费用计算

---

**注意**：费用是按照总金额的一定比例计算的，而不是额外添加的。

### 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**：
- 项目间的支付
- 注册在 JBFeelessAddresses 的地址
- 内部转账

---

## 持有的费用

当规则集元数据中的 `holdFees` 为 true 时：

---

**费用处理**：

28 天后，持有的费用可以分配给费用受益者（项目 #1）。

---

## 集成建议

### 对于支付集成者

1. **始终设置合理的 `minReturnedTokens` 值**，以防止抢先交易
2. 在估算交易成本时考虑数据钩子的 Gas 成本
3. 在用户界面中优雅地处理支付钩子的回退情况
4. 验证元数据编码是否符合钩子的预期

### 对于钩子开发者

1. **保持 `beforePayRecordedWith()` 的只读和轻量级** —— 它会在每次支付时执行
2. 在 `afterPayRecordedWith()` 中优雅地处理失败情况，不要锁定用户的资金
3. 验证 `msg.sender` 是否是授权的终端
4. **考虑重入机制** —— 钩子在执行前会接收资金

### 对于项目运营者

1. **锁定关键的 splits**，以防止资金流失
2. 对于需要治理控制的项目，使用审批钩子
3. 定期分配预留的代币
4. 设置适当的支付限额，以控制风险

### Gas 优化技巧

1. **尽可能批量操作**（批量排队多个规则集）
2. 对于 721 钩子，使用信用而不是直接支付
3. 在 Gas 较低的时候分配预留代币
4. 在分配剩余资金时考虑总剩余资金和终端剩余资金之间的权衡

---

## 常见问题

1. **将 `minReturnedTokens` 设置为 0**：容易受到中间人攻击
2. **忘记包含锁定的 splits**：会导致交易回退
3. **假设预留代币会立即分配**：代币会不断累积
4. **没有正确处理钩子元数据**：可能导致默默失败或交易回退
5. **忽略审批钩子的延迟**：如果排队太晚，规则集会被拒绝
6. **低估多钩子支付的 Gas 成本**：会导致交易失败
7. **在现金提取前没有验证剩余资金的存在**：会导致 Gas 的浪费

---

## 核心基础设施合约

### JBDirectory

该目录负责管理项目的终端和控制器分配。

#### 存储架构

---

#### 终端管理

`setTerminalsOf()` 会替换整个终端数组：
- 通过嵌套循环验证是否存在重复项
- 需要 `SET_TERMINALS` 权限，或者调用者必须是项目控制器
- 检查规则集的 `setTerminalsAllowed` 标志（如果控制器是调用者，则可以忽略此检查）

**primaryTerminalOf()** 的实现：
1. 如果设置了主要的终端，则返回该终端
2. 否则，返回第一个接受该代币的终端
3. 如果没有找到合适的终端，则返回空地址

#### 控制器迁移

`setControllerOf()` 负责处理控制器迁移：
1. 需要 `SET-controller` 权限，或者是通过允许列表首次设置的控制器
2. 检查规则集的 `setControllerAllowed` 标志
3. 如果旧控制器支持该接口，调用 `IJBMigratable.migrate()`

**关键点**：第一个控制器只能由 `isAllowedToSetFirstController` 允许列表中的地址设置

---

### JBProjects

ERC-721 合约，每个代币代表一个 Juicebox 项目。

#### 项目创建

`count` 变量同时用作项目总数计数器和下一个项目的 ID。

#### 元数据解析

---

**优雅降级**：如果没有设置解析器，返回空字符串，以防止交易回退。

#### ERC-2771 支持

覆盖 `_msgSender()`、`_msgData()` 和 `_contextSuffixLength()`，以支持通过可信转发器进行元交易。

---

### JBPermissions

基于位图的权限系统，支持细粒度的访问控制。

---

#### 存储架构

---

`uint256` 中的每个位代表 256 种可能的权限之一。项目 ID `0` 是通配符，允许访问所有项目的权限。

#### 权限检查

**hasPermission()** 实现了分层权限检查：

---

**hasPermissions()**（批量检查）：
- 如果存在 ROOT 权限，则立即返回 true
- 遍历所有请求的权限
- 如果缺少任何权限，则返回 false

#### setPermissionsFor() 中的安全限制

---

**边缘情况**：
- 权限 ID 0 是保留的，不能被设置
- 权限 ID 大于 255 会导致 `PermissionIdOutOfBoundsException`
- 空的权限数组是有效的（会清除所有权限）

---

### JBTokens

JBTokens 系统支持双重余额机制，同时支持未领取的信用和 ERC-20 代币。

#### 存储设计

---

#### 铸造逻辑

`mintFor()` 根据 ERC-20 的存在情况进行选择：

---

#### 烧毁逻辑

**burnFrom()** 先销毁信用，然后再销毁代币：

---

#### ERC-20 的部署

`deployERC20For()` 使用最小的代理克隆：
---

#### 自定义 ERC20 代币的集成

JBTokens 系统支持自定义 ERC20 代币，从而实现更高级的代币经济机制。

#### 自定义代币的工作原理

当使用 `setTokenFor()` 配置自定义代币时：

---

**关键点**：设置自定义代币不会迁移现有的信用。信用持有者必须调用 `claimTokensFor()` 将信用转换为 ERC20 代币。

---

## 分配机制

### 分批分配

**优点**：Gas 使用效率较高（一次操作即可完成）
**缺点**：接收者需要等待手动触发
**缺点**：大量积累可能导致 Gas 限制

### 每次支付分配

**优点**：可以立即分配
**缺点**：每次支付的 Gas 成本较高

---

## Splits 系统的详细信息

### 存储优化

为了提高 Gas 使用效率，Splits 使用打包存储方式：

---

### 锁定状态的 splits 行为

在更新 splits 时：
1. 必须包含所有当前锁定的 splits
2. 锁定期限只能延长，不能缩短
3. 锁定状态的 splits 的其他属性不能更改

**边缘情况**：如果被锁定的 splits 的接收者变成了无法接收资金的合约，这些资金将一直被锁定，直到锁定期限结束。

---

## Split 的执行

---

**关键点**：Split 钩子在调用 `processSplitWith()` 之前会优先接收资金。恶意钩子可能会窃取资金。

---

## 买回钩子的决策逻辑

### 铸造与交换的比较

---

### TWAP 计算

---

### 滑动容忍度的分级

---

## 失败处理

---

**关键点**：失败的交换不会导致整个支付流程回退。钩子会优雅地回退到标准铸造模式。

---

## 721 钩子的层级机制

### 支付处理流程

---

### 信用系统

---

**权衡**：信用系统提供了灵活性，但：
- 会因四舍五入产生微小费用
- 信用不能提取，只能用于 NFT
- 如果钩子被更改，信用将丢失

### 现金提取的权重计算

每个 NFT 的现金提取价值等于其对应的层级价格：

---

**totalCashOutWeight()` 函数汇总所有未偿还的 NFT 价值，用于计算比例。

**关键点**：如果 NFT 价格波动较大，低价 NFT 的持有者获得的现金提取比例会相应减少。

---

## 费用机制

### 费用计算

---

**注意**：费用是按照总金额的一定比例计算的，而不是额外添加的。

### 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**：
- 项目间的支付
- 注册在 JBFeelessAddresses 的地址
- 内部转账

---

## 持有的费用

当规则集元数据中的 `holdFees` 为 true 时：

---

**费用处理**：

28 天后，持有的费用可以分配给费用受益者（项目 #1）。

---

## 集成建议

### 对于支付集成者

1. **始终设置合理的 `minReturnedTokens` 值**，以防止抢先交易
2. 在估算交易成本时考虑数据钩子的 Gas 成本
3. 在用户界面中优雅地处理支付钩子的回退情况
4. 验证元数据编码是否符合钩子的预期

### 对于钩子开发者

1. **保持 `beforePayRecordedWith()` 的只读和轻量级** —— 它会在每次支付时执行
2. 在 `afterPayRecordedWith()` 中优雅地处理失败情况，不要锁定用户的资金
3. 验证 `msg.sender` 是否是授权的终端
4. **考虑重入机制** —— 钩子在执行前会接收资金

### 对于项目运营者

1. **锁定关键的 splits**，以防止资金流失
2. 对于需要治理控制的项目，使用审批钩子
3. 定期分配预留的代币
4. 设置适当的支付限额，以控制风险

### Gas 优化技巧

1. **尽可能批量操作**（批量排队多个规则集）
2. 对于 721 钩子，使用信用而非直接支付
3. 在 Gas 较低的时候分配预留代币
4. 在分配剩余资金时考虑总剩余资金和终端剩余资金之间的权衡

---

## 常见问题

1. **将 `minReturnedTokens` 设置为 0**：容易受到中间人攻击
2. **忘记包含锁定的 splits**：会导致交易回退
3. **假设预留代币会立即分配**：代币会不断累积
4. **没有正确处理钩子元数据**：可能导致默默失败或交易回退
5. **忽略审批钩子的延迟**：如果排队太晚，规则集会被拒绝
6. **低估多钩子支付的 Gas 成本**：会导致交易失败
7. **在现金提取前没有验证剩余资金的存在**：会导致 Gas 的浪费

---

## 核心基础设施合约

### JBDirectory

该目录负责管理项目的终端和控制器分配。

#### 存储架构

---

#### 终端管理

`setTerminalsOf()` 会替换整个终端数组：
- 通过嵌套循环验证是否存在重复项
- 需要 `SET_TERMINALS` 权限，或者调用者必须是项目控制器
- 检查规则集的 `setTerminalsAllowed` 标志（如果控制器是调用者，则可以忽略此检查）

**primaryTerminalOf()** 的实现：
1. 如果设置了主要的终端，则返回该终端
2. 否则，返回第一个接受该代币的终端
3. 如果没有找到合适的终端，则返回空地址

#### 控制器迁移

`setControllerOf()` 负责处理控制器迁移：
1. 需要 `SET_controller` 权限，或者是通过允许列表首次设置的控制器
2. 检查规则集的 `setControllerAllowed` 标志
3. 如果旧控制器支持该接口，调用 `IJBMigratable.migrate()``

**关键点**：第一个控制器只能由 `isAllowedToSetFirstController` 允许列表中的地址设置

---

### JBProjects

ERC-721 合约，每个代币代表一个 Juicebox 项目。

#### 项目创建

`count` 变量同时用作项目总数计数器和下一个项目的 ID。

#### 元数据解析

---

**优雅降级**：如果没有设置解析器，返回空字符串，以防止交易回退。

#### ERC-2771 支持

覆盖 `_msgSender()`、`_msgData()` 和 `_contextSuffixLength()`，以支持通过可信转发器进行元交易。

---

### JBPermissions

基于位图的权限系统，支持细粒度的访问控制。

---

#### 存储架构

---

`uint256` 中的每个位代表 256 种可能的权限之一。项目 ID `0` 是通配符，允许访问所有项目的权限。

#### 权限检查

**hasPermission()** 实现了分层权限检查：

---

**hasPermissions()**（批量检查）：
- 如果存在 ROOT 权限，则立即返回 true
- 遍历所有请求的权限
- 如果缺少任何权限，则返回 false

#### setPermissionsFor() 中的安全限制

---

**边缘情况**：
- 权限 ID 0 是保留的，不能被设置
- 权限 ID 大于 255 会导致 `PermissionIdOutOfBoundsException`
- 空的权限数组是有效的（会清除所有权限）

---

### JBTokens

JBTokens 系统支持双重余额机制，同时支持未领取的信用和 ERC-20 代币。

#### 存储设计

---

#### 铸造逻辑

`mintFor()` 根据 ERC-20 的存在情况进行选择：

---

#### 烧毁逻辑

**burnFrom()** 先销毁信用，然后再销毁代币：

---

#### ERC-20 的部署

`deployERC20For()` 使用最小的代理克隆：

---

#### 自定义 ERC20 代币的集成

JBTokens 系统支持自定义 ERC20 代币，从而实现更高级的代币经济机制。

#### 自定义代币的工作原理

当使用 `setTokenFor()` 配置自定义代币时：

---

**关键点**：设置自定义代币不会迁移现有的信用。信用持有者必须调用 `claimTokensFor()` 将信用转换为 ERC20 代币。

---

## 分配机制

### 分批分配

**优点**：Gas 使用效率较高（一次操作即可完成）
**缺点**：接收者需要等待手动触发
**缺点**：大量积累可能导致 Gas 限制

### 每次支付分配

**优点**：可以立即分配
**缺点**：每次支付的 Gas 成本较高

---

## Splits 系统的详细信息

### 存储优化

为了提高 Gas 使用效率，Splits 使用打包存储方式：

---

### 锁定状态的 splits 行为

在更新 splits 时：
1. 必须包含所有当前锁定的 splits
2. 锁定期限只能延长，不能缩短
3. 锁定状态的 splits 的其他属性不能更改

**边缘情况**：如果被锁定的 splits 的接收者变成了无法接收资金的合约，这些资金将一直被锁定，直到锁定期限结束。

---

## Split 的执行

---

## 买回钩子的决策逻辑

### 铸造与交换的比较

---

### TWAP 计算

---

### 滑动容忍度的分级

---

## 失败处理

---

**关键点**：失败的交换不会导致整个支付流程回退。钩子会优雅地回退到标准铸造模式。

---

## 721 钩子的层级机制

### 支付处理流程

---

### 信用系统

---

**权衡**：信用系统提供了灵活性，但：
- 会因四舍五入产生微小费用
- 信用不能提取，只能用于 NFT
- 如果钩子被更改，信用将丢失

### 现金提取的权重计算

每个 NFT 的价值等于其对应的层级价格：

---

**totalCashOutWeight()** 函数汇总所有未偿还的 NFT 价值，用于计算比例。

---

**关键点**：如果 NFT 价格波动较大，低价 NFT 的持有者获得的现金提取比例会相应减少。

---

## 费用机制

### 费用计算

---

**注意**：费用是按照总金额的一定比例计算的，而不是额外添加的。

### 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**：
- 项目间的支付
- 注册在 JBFeelessAddresses 的地址
- 内部转账

---

## 持有的费用

当规则集元数据中的 `holdFees` 为 true 时：

---

**费用处理**：

28 天后，持有的费用可以分配给费用受益者（项目 #1）。

---

## 集成建议

### 对于支付集成者

1. **始终设置合理的 `minReturnedTokens` 值**，以防止抢先交易
2. 在估算交易成本时考虑数据钩子的 Gas 成本
3. 在用户界面中优雅地处理支付钩子的回退情况
4. 验证元数据编码是否符合钩子的预期

### 对于钩子开发者

1. **保持 `beforePayRecordedWith()` 的只读和轻量级** —— 它会在每次支付时执行
2. 在 `afterPayRecordedWith()` 中优雅地处理失败情况，不要锁定用户的资金
3. 验证 `msg.sender` 是否是授权的终端
4. **考虑重入机制** —— 钩子在执行前会接收资金

### 对于项目运营者

1. **锁定关键的 splits**，以防止资金流失
2. 对于需要治理控制的项目，使用审批钩子
3. 定期分配预留的代币
4. 设置适当的支付限额，以控制风险

### Gas 优化技巧

1. **尽可能批量操作**（批量排队多个规则集）
2. 对于 721 钩子，使用信用而非直接支付
3. 在 Gas 较低的时候分配预留代币
4. 在分配剩余资金时考虑总剩余资金和终端剩余资金之间的权衡

---

## 常见问题

1. **将 `minReturnedTokens` 设置为 0**：容易受到中间人攻击
2. **忘记包含锁定的 splits**：会导致交易回退
3. **假设预留代币会立即分配**：代币会不断累积
4. **没有正确处理钩子元数据**：可能导致默默失败或交易回退
5. **忽略审批钩子的延迟**：如果排队太晚，规则集会被拒绝
6. **低估多钩子支付的 Gas 成本**：会导致交易失败
7. **在现金提取前没有验证剩余资金的存在**：会导致 Gas 的浪费

---

## 核心基础设施合约

### JBDirectory

该目录负责管理项目的终端和控制器分配。

#### 存储架构

---

#### 终端管理

`setTerminalsOf()` 会替换整个终端数组：
- 通过嵌套循环验证是否存在重复项
- 需要 `SET_TERMINALS` 权限，或者调用者必须是项目控制器
- 检查规则集的 `setTerminalsAllowed` 标志（如果控制器是调用者，则可以忽略此检查）

**primaryTerminalOf()** 的实现：
1. 如果设置了主要的终端，则返回该终端
2. 否则，返回第一个接受该代币的终端
3. 如果没有找到合适的终端，则返回空地址

#### 控制器迁移

`setControllerOf()` 负责处理控制器迁移：
1. 需要 `SET_controller` 权限，或者是通过允许列表首次设置的控制器
2. 检查规则集的 `setControllerAllowed` 标志
3. 如果旧控制器支持该接口，调用 `IJBMigratable.migrate()``

**关键点**：第一个控制器只能由 `isAllowedToSetFirstController` 允许列表中的地址设置

---

### JBProjects

ERC-721 合约，每个代币代表一个 Juicebox 项目。

#### 项目创建

`count` 变量同时用作项目总数计数器和下一个项目的 ID。

#### 元数据解析

---

**优雅降级**：如果没有设置解析器，返回空字符串，以防止交易回退。

#### ERC-2771 支持

覆盖 `_msgSender()`、`_msgData()` 和 `_contextSuffixLength()`，以支持通过可信转发器进行元交易。

---

### JBPermissions

基于位图的权限系统，支持细粒度的访问控制。

---

#### 存储架构

---

`uint256` 中的每个位代表 256 种可能的权限之一。项目 ID `0` 是通配符，允许访问所有项目的权限。

#### 权限检查

**hasPermission()** 实现了分层权限检查：

---

**hasPermissions()**（批量检查）：
- 如果存在 ROOT 权限，则立即返回 true
- 遍历所有请求的权限
- 如果缺少任何权限，则返回 false

#### setPermissionsFor() 中的安全限制

---

**边缘情况**：
- 权限 ID 0 是保留的，不能被设置
- 权限 ID 大于 255 会导致 `PermissionIdOutOfBoundsException`
- 空的权限数组是有效的（会清除所有权限）

---

### JBTokens

JBTokens 系统支持双重余额机制，同时支持未领取的信用和 ERC-20 代币。

#### 存储设计

---

#### 铸造逻辑

`mintFor()` 根据 ERC-20 的存在情况进行选择：

---

#### 烧毁逻辑

**burnFrom()** 先销毁信用，然后再销毁代币：

---

#### ERC-20 的部署

`deployERC20For()` 使用最小的代理克隆：

---

#### 自定义 ERC20 代币的集成

JBTokens 系统支持自定义 ERC20 代币，从而实现更高级的代币经济机制。

#### 自定义代币的工作原理

当使用 `setTokenFor()` 配置自定义代币时：

---

**关键点**：设置自定义代币不会迁移现有的信用。信用持有者必须调用 `claimTokensFor()` 将信用转换为 ERC20 代币。

---

## 分配机制

### 分批分配

**优点**：Gas 使用效率较高（一次操作即可完成）
**缺点**：接收者需要等待手动触发
**缺点**：大量积累可能导致 Gas 限制

### 每次支付分配

**优点**：可以立即分配
**缺点**：每次支付的 Gas 成本较高

---

## Splits 系统的详细信息

### 存储优化

为了提高 Gas 使用效率，Splits 使用打包存储方式：

---

### 锁定状态的 splits 行为

在更新 splits 时：
1. 必须包含所有当前锁定的 splits
2. 锁定期限只能延长，不能缩短
3. 锁定状态的 splits 的其他属性不能更改

**边缘情况**：如果被锁定的 splits 的接收者变成了无法接收资金的合约，这些资金将一直被锁定，直到锁定期限结束。

---

## Split 的执行

---

## 买回钩子的决策逻辑

### 铸造与交换的比较

---

### TWAP 计算

---

### 滑动容忍度的分级

---

## 失败处理

---

**关键点**：失败的交换不会导致整个支付流程回退。钩子会优雅地回退到标准铸造模式。

---

## 721 钩子的层级机制

### 支付处理流程

---

### 信用系统

---

**权衡**：信用系统提供了灵活性，但：
- 会因四舍五入产生微小费用
- 信用不能提取，只能用于 NFT
- 如果钩子被更改，信用将丢失

### 现金提取的权重计算

每个 NFT 的价值等于其对应的层级价格：

---

**totalCashOutWeight()** 函数汇总所有未偿还的 NFT 价值，用于计算比例。

---

**关键点**：如果 NFT 价格波动较大，低价 NFT 的持有者获得的现金提取比例会相应减少。

---

## 费用机制

### 费用计算

---

**注意**：费用是按照总金额的一定比例计算的，而不是额外添加的。

### 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**

---

## 费用的适用范围

费用适用于：
- 向非项目地址的支付
- 使用剩余资金的分配
- 税率低于 100% 的现金提取

**费用免除情况**

---

## 集成建议

### 对于支付集成者

1. **始终设置合理的 `minReturnedTokens` 值**，以防止抢先交易
2. 在估算交易成本时考虑数据钩子的 Gas 成本
3. 在用户界面中优雅地处理支付钩子的回退情况
4. 验证元数据编码是否符合钩子的预期

### 对于钩子开发者

1. **保持 `beforePayRecordedWith()` 的只读和轻量级** —— 它会在每次支付时执行
2. 在 `afterPayRecordedWith()` 中优雅地处理失败情况，不要锁定用户的资金
3. 验证 `msg.sender` 是否是授权的终端
4. **考虑重入机制** —— 钩子在执行前会接收资金

### 对于项目运营者

1. **锁定关键的 splits**，以防止资金流失
2. 对于需要治理控制的项目，使用审批钩子
3. 定期分配预留的代币
4. 设置适当的支付限额，以控制风险

### Gas 优化技巧

1. **尽可能批量操作**（批量排队多个规则集）
2. 对于 721 钩子，使用信用而非直接支付
3. 在 Gas 较低的时候分配预留代币
4. 在分配剩余资金时考虑总剩余资金和终端剩余资金之间的权衡

---

## 常见问题

1. **将 `minReturnedTokens` 设置为 0**：容易受到中间人攻击
2. **忘记包含锁定的 splits**：会导致交易回退
3. **假设预留代币会立即分配**：代币会不断累积
4. **没有正确处理钩子元数据**：可能导致默默失败或交易回退
5. **忽略审批钩子的延迟**：如果排队太晚，规则集会被拒绝
6. **低估多钩子支付的 Gas 成本**：会导致交易失败
7. **在现金提取前没有验证剩余资金的存在**：会导致 Gas 的浪费

---

## 核心基础设施合约

### JBDirectory

该目录负责管理项目的终端和控制器分配。

#### 存储架构

---

#### 终端管理

`setTerminalsOf()` 会替换整个终端数组：
- 通过嵌套循环验证是否存在重复项
- 需要 `SET_TERMINALS` 权限，或者调用者必须是项目控制器
- 检查规则集的 `setTerminalsAllowed` 标志（如果控制器是调用者，则可以忽略此检查）

**primaryTerminalOf()** 的实现：
1. 如果设置了主要的终端，则返回该终端
2. 否则，返回第一个接受该代币的终端
3. 如果没有找到合适的终端，则返回空地址

#### 控制器迁移

`setControllerOf()` 负责处理控制器迁移：
1. 需要 `SET_controller` 权限，或者是通过允许列表首次设置的控制器
2. 检查规则集的 `setControllerAllowed` 标志
3. 如果旧控制器支持该接口，调用 `IJBMigratable.migrate()`