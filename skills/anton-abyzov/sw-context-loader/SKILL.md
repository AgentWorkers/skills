---
name: context-loader
description: **说明 SpecWeave 如何通过 Claude 的原生渐进式数据披露机制及子代理并行化技术来实现上下文处理的高效性。**  
适用于询问令牌使用方式、上下文管理机制，或 SpecWeave 在处理大型项目时的扩展能力。该内容详细阐述了 SpecWeave 如何利用 Claude 的内置功能（而无需进行自定义缓存处理）。
---

# SpecWeave中的上下文管理

## 概述

SpecWeave通过**两种Claude Code的原生机制**实现了高效的上下文使用：

1. **渐进式加载**（Skills）——Claude内置的技能加载系统
2. **子代理并行化**——用于并行工作的隔离上下文窗口

**重要提示**：SpecWeave不使用自定义的上下文管理机制或缓存系统，而是充分利用Claude的原生功能。

---

## 1. 渐进式加载（Skills）

### 工作原理

Claude Code使用**两级渐进式加载机制**来加载技能：

#### 第一级：仅加载元数据（始终加载）

**Claude最初看到的内容：**
- 仅加载YAML格式的前缀信息（技能名称和描述）
- 每个技能大约包含50-100个标记（tokens）
- 所有技能的元数据都可见
- Claude可以判断哪些技能与当前任务相关

#### 第二级：按需加载完整技能内容

**Claude会加载的内容：**
- **仅当**某个技能与当前任务相关时，才会加载该技能的完整内容
- 这种机制可以避免在只需要2-3个技能时加载35个或更多技能（每个技能可能包含175,000多个标记），从而节省标记资源

### 示例工作流程

---

### 参考资料
- [什么是Skills？](https://support.claude.com/en/articles/12512176-what-are-skills)
- [代理技能工程](https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills)

> “Skills通过渐进式加载机制进行工作——Claude会判断哪些技能与任务相关，并仅加载完成任务所需的信息，从而防止上下文窗口过载。”

---

## 2. 子代理并行化

### 工作原理

Claude Code中的子代理拥有**隔离的上下文窗口**：

**优点：**
1. **上下文隔离**：
   - 每个子代理从空上下文状态开始
   - 不会继承主线对话中的100,000个标记
   - 可以加载自己相关的技能

2. **并行处理**：
   - 多个代理可以同时工作
   - 每个代理都有自己的上下文资源限制
   - 处理结果会被合并回主线对话中

3. **标记资源优化**：
   - 主线对话的标记限制为200,000个
   - 子代理1的标记限制也为200,000个
   - 子代理2的标记限制同样为200,000个
   - **实际处理能力**：通过并行处理，总标记量可达到600,000个以上

### 示例工作流程

---

### 参考资料
- [子代理文档](https://docs.claude.com/en/docs/claude-code/sub-agents)

---

## 实际的标记资源节省效果

### 渐进式加载的节省效果

**场景**：用户询问关于Next.js的信息

**不使用渐进式加载时：**
---

**使用渐进式加载时：**
---

### 子代理的节省效果

**场景**：复杂的跨领域任务

**单代理处理方式：**
---

**子代理处理方式：**
---

**注意**：具体的节省百分比会因任务复杂性而有所不同。这些数据是基于典型使用模式估算的。

---

## SpecWeave如何利用这些机制

### 1. 技能组织（渐进式加载）

SpecWeave对**35个以上的技能**进行了清晰、有针对性的描述：

**这样做的好处：**
- 清晰的描述有助于Claude快速判断技能的相关性
- 避免加载不相关的技能
- 最大化渐进式加载带来的效率提升

### 2. 代理协调（子代理并行化）

SpecWeave的**角色编排器**技能会自动：
- 检测跨领域任务
- 启动相应的子代理（如项目经理、架构师、DevOps等）
- 每个子代理仅加载与其任务相关的技能
- 将处理结果合并回主线对话中

**示例：**

---

## 常见误解

### ❌ 误解1：“SpecWeave使用了自定义的上下文管理机制”

**事实**：SpecWeave使用的是Claude的原生渐进式加载机制。技能的加载基于Claude的自动相关性判断，而非自定义的YAML文件。

### ❌ 误解2：“SpecWeave会缓存已加载的上下文”

**事实**：SpecWeave没有使用自定义缓存机制。Claude Code内部处理缓存（如果适用的话），但SpecWeave本身不添加额外的缓存层。

### ❌ 误解3：“能够节省70-90%的标记资源”

**事实**：标记资源的节省比例因任务而异：
- 简单任务：节省90%以上（只需加载1-2个技能，而非全部35个）
- 复杂任务：节省50-70%（加载5-10个技能，并使用子代理）
- 具体百分比取决于任务的复杂性

### ✅ 真相：“这一切都是自动完成的”

**事实**：渐进式加载和子代理的机制都是自动执行的。用户无需进行任何配置。Claude会自动处理技能的加载和子代理的上下文隔离。

---

## 最佳实践

### 技能描述

**建议：**
- 明确说明技能的具体功能
- 包含用户可能使用的触发关键词
- 明确列出所使用的技术或框架

**不建议：**
- 使用模糊的描述（如“帮助编码”）
- 省略关键的触发条件
- 将不相关的技能混合到一个技能描述中

### 子代理的使用

**何时使用子代理：**
- 处理跨领域任务（前端、后端、DevOps等）
- 需要同时处理多个功能的任务
- 需要探索大型代码库（不同模块）

**何时不使用子代理：**
- 处理简单的单领域任务
- 需要共享上下文的顺序任务
- 当主线对话的上下文资源已经很有限时

---

## 调试上下文使用情况

### 检查当前正在使用的技能

当Claude提到某个技能时：

**这意味着：**
- 渐进式加载机制生效
- 仅加载了与Next.js相关的技能（而非全部35个技能）
- 上下文使用效率较高

### 检查子代理的使用情况

当Claude启动子代理时：

**这意味着：**
- 子代理并行化正在运行
- 每个子代理都有独立的上下文环境
- 处理过程高效且跨领域协同

---

## 总结

SpecWeave通过以下方式实现上下文效率的提升：
1. **渐进式加载（Claude的原生机制）**：仅加载与任务相关的技能，首先加载元数据，从而在简单任务中节省超过90%的标记资源
2. **子代理并行化（Claude Code的原生机制）**：通过隔离的上下文窗口实现并行处理，在复杂任务中节省50-70%的标记资源

**SpecWeave没有使用任何自定义的上下文管理或缓存机制，而是充分利用了Claude的原生功能。**

---

## 参考资料
- [Claude技能文档](https://support.claude.com/en/articles/12512176-what-are-skills)
- [代理技能工程博客](https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills)
- [子代理文档](https://docs.claude.com/en/docs/claude-code/sub-agents)