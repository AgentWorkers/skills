---
name: tdd-discipline
description: **测试驱动开发（Test-Driven Development, TDD）方法论**  
在实现新功能或修复错误时，应优先编写测试用例。首先运行测试，观察其是否失败；接着编写最简短的代码来使测试通过；最后对代码进行重构。这种方法可以确保未经测试的代码不会被部署到生产环境中。
metadata:
  author: misskim
  version: "1.0"
  origin: Concept from obra/superpowers test-driven-development, condensed for practical use
---

# TDD（测试驱动开发）规范

## 核心开发周期

```
RED → GREEN → REFACTOR → 반복
```

### RED（红色阶段）：编写失败的测试用例
- 每个测试用例只验证一个功能点。
- 为测试用例起明确的名称（例如：“rejects empty email” ✅， “test1” ❌）。
- 使用实际代码进行测试（尽量减少使用模拟对象）。

### 验证：确认测试是否失败（必须执行！禁止跳过此步骤）
```bash
npm test path/to/test.test.ts
```
- 测试是否真的失败了？（注意：这里指的是测试用例预期的失败结果，而非程序本身的错误）
- 失败信息是否与预期一致？
- 失败是由于功能未实现导致的吗？（确认不是代码中的拼写错误）

### GREEN（绿色阶段）：编写最简化的代码
- 编写能够通过测试的最简单代码。
- 禁止添加新功能或进行代码重构。
- 遵循YAGNI原则（You Ain’t Gonna Need It，即“你不会需要这个代码”）。

### REFACTOR（重构阶段）：优化代码
- 删除重复代码，改进函数命名，提取辅助函数。
- 确保测试用例仍然能够正常通过。
- 禁止添加新的功能。

## 违反规范的后果

```
테스트 전에 코드 작성했으면? → 삭제. 처음부터.
```

- 将代码标记为“仅供参考” ❌
- 用测试用例作为开发依据，但实际不执行测试 ❌
- 完全忽略测试用例 ✅

## 适用场景

**始终需要执行TDD：**
- 实现新功能时。
- 修复漏洞时（首先编写能够复现漏洞的测试用例！）。
- 修改代码逻辑时。

**例外情况（由团队负责人判断）：**
- 一次性开发的原型代码。
- 配置文件。
- 生成的临时代码。

## 常见的合理化借口及反驳理由：

| 常见借口 | 现实情况 |
|------|------|
| “代码太简单了，不需要测试” | 即使简单的代码也可能出错，测试只需花费30秒。 |
| “以后再写测试” | “以后”可能永远不会到来；不编写测试就等于什么都没有证明。 |
| “TDD太慢了” | 实际上，TDD的调试效率更高。 |
| “我已经手动测试过了” | 手动测试没有记录，也无法重复执行。 |
| “删除这些代码会浪费时间” | 未经验证的代码才是真正的浪费。 |

## 修复漏洞时的TDD流程：
1. 编写能够复现漏洞的测试用例。
2. 确认测试用例能否捕获到漏洞。
3. 修复代码。
4. 再编写测试用例，确保修复后的代码仍然能够通过测试。
5. 通过回归测试来验证修复的稳定性。