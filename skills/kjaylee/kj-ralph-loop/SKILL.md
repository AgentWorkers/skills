---
name: ralph-loop
description: AI自主实现方法论：在收到实现/开发/编码请求时，该方法论会自动被应用。其主要流程包括：由“母代理”（Mother Agent）生成多个“子代理”（Child Agents），并由“母代理”负责管理这些子代理的工作。具体步骤如下：  
1. 根据技术规范（specifications）生成详细的实现计划（implementation_plan.md）；  
2. 按照计划逐个任务进行实现；  
3. 完成每个任务后进行两轮评审；  
4. 对实现结果进行测试；  
5. 根据测试结果重复上述流程，直至达到预期效果。
---

# Ralph Loop v2

结合了Geoffrey Huntley的AI自主开发方法论以及Superpowers中的优秀实践。

## 从Superpowers中吸收的改进措施：
- ✅ **两阶段评审**：确保代码质量符合规范（原方案：由母代理直接检查，无评审流程）
- ✅ **必须先验证**：在声明“完成”之前，必须提供测试执行的证据（原方案：仅依赖工作代理的报告）
- ✅ **系统化调试**：如果三次尝试都失败，则重新评估架构（原方案：无限重试）
- ✅ **严格执行YAGNI原则**：如果规范中没有要求，禁止实现相关功能（原方案：为隐性要求）
- ✅ **明确列出风险警示（Red Flags）**：避免常见的开发错误

## 未采纳的改进措施（基于Superpowers的批评）：
- ❌ **过度强制使用TDD**：对于HTML5游戏或单文件工具来说，这并不适用。我们的主要产品是简单的HTML游戏或工具，TDD反而会降低开发效率。仅在复杂的项目（如Rust/Godot）中选择使用TDD。
- ❌ **Git Worktrees**：在OpenClaw环境中没有必要使用。子代理已经能够实现上下文隔离。
- ❌ **为每个代码评审任务单独启动子代理**：这会增加成本。母代理可以直接执行两阶段评审。
- ❌ **要求进行200-300字的头脑风暴**：我们遵循Master的指令，立即开始行动。苏格拉底式的提问方式并不适用。
- ❌ **依赖Claude Code插件**：OpenClaw本身已经具备相应的功能。

## 核心原则：
1. **每个任务一个周期**：将任务分解成小块，保持开发环境的效率。
2. **三层代理结构**：主代理（Master）、母代理（Mother）和工作代理（Worker）。
3. **文件存储在内存中**：状态数据存储在磁盘上。
4. **使用测试和代码检查工具（Backpressure）来保证质量。
5. **必须先验证**：只有在有证据支持的情况下才能声明“完成”。
6. **三次失败即重新评估**：如果同一个问题出现三次失败，必须重新评估架构。
7. **严格执行YAGNI原则**：如果没有规范要求，禁止实现相关功能。

## 代理结构（代码示例请参见```
┌─────────────────────────────────────────────┐
│  메인 에이전트 (Main)                        │
│  • 사용자와 대화                             │
│  • Ralph Loop 마더 spawn                    │
│  • 전체 조율 및 의사결정                      │
└──────────────────┬──────────────────────────┘
                   │ spawn (label: ralph-mother)
                   ▼
┌─────────────────────────────────────────────┐
│  마더 에이전트 (Mother)                      │
│  • specs/ 폴더 생성 및 관리                   │
│  • IMPLEMENTATION_PLAN.md 생성/업데이트       │
│  • 워커 서브에이전트 spawn                    │
│  • 🆕 2단계 리뷰 수행 (스펙 준수 → 품질)      │
│  • 진행 상황 메인에게 보고                    │
└──────────────────┬──────────────────────────┘
                   │ spawn (label: ralph-worker-N)
                   ▼
┌─────────────────────────────────────────────┐
│  워커 에이전트 (Worker)                      │
│  • 단일 태스크 구현                          │
│  • 🆕 자체 검증 실행 (테스트/curl/브라우저)    │
│  • 🆕 검증 증거 포함하여 보고                  │
│  • 결과 마더에게 보고                        │
└─────────────────────────────────────────────┘
```）

## 工作流程：

### 主代理（Master Agent）的角色：
- 当用户提出实现或开发请求时：
  - 理解并明确需求。
  - 启动Ralph Loop的母代理（Mother Agent）。
  - 接收母代理的报告，并向用户反馈进度。
  - 在必要时做出决策并调整开发方向。

### 母代理（Mother Agent）的角色：
- 接收到需求后：
  - **阶段1：需求定义**：
    - 为每个功能编写详细的规范文档（每个功能对应一个文件；如果可以用一句话描述，则不需要文件）。
  - **阶段2：计划制定**：
    - 分析规范与当前代码之间的差异。
    - 制定优先级排序的任务列表。
    - 每个任务的时间限制为2-5分钟；如果任务太复杂，需要进一步分解。
  - **阶段3：代码实现**：
    - 分析规范和相关代码。
    - 实现功能。
    - 执行验证并收集证据：
      - 如果有测试用例，执行测试并捕获结果。
      - 如果是Web应用，通过curl或浏览器进行实际测试。
      - 如果是命令行工具，执行命令并捕获结果。
    - 将结果（包括成功或失败以及验证证据）报告给主代理。

## 🆕 系统化调试协议：
- 当遇到错误、异常或意外行为时：
  - **阶段1：查找根本原因**（在尝试修复之前必须完成）：
    - 仔细阅读错误信息（包括堆栈跟踪）。
    - 确认问题是否可以重现。
    - 查看最近的代码变更（使用git diff）。
    - 跟踪数据流。
  - **阶段2：建立假设并进行最小范围的测试**：
    - 提出一个假设：“X是根本原因，因为Y”。
    - 通过最小的改动来验证这个假设。
    - 每次只修改一个部分。
  - **阶段3：三次失败即停止**：
    - 如果同一个问题出现三次失败，立即停止开发。
    - 可能是架构或设计上的问题。
    - 向主代理报告，并由主代理向上级（Master）汇报。
    - **绝对禁止进行第四次修改**。

## 🆕 风险警示（Red Flags，立即停止的规则）：
| 🚫 错误行为 | ✅ 正确的做法 |
|-------------|---------------|
| “大概没问题” | 先执行验证，再根据结果判断。 |
| “只需要修复这个部分”（即使已经尝试了三次） | 重新评估整个架构。 |
- 在没有测试的情况下声明“完成” | 附上验证证据。 |
- 添加规范中没有的功能 | 严格执行YAGNI原则，只实现规范中明确要求的功能。 |
- 同时进行多次修改 | 每次只修改一个部分。 |
- 仅依赖工作代理的报告 | 必须亲自验证结果。 |
- “以后再测试” | 立即进行验证，或者将任务标记为未完成。 |

## 根据项目规模选择合适的开发方法：
| 项目规模 | 是否使用TDD | 是否进行两阶段评审 | 是否采用三层代理结构 |
|------|-----|-----------|------------|
| **简单的HTML游戏/工具** | 不适用 | ✅ 由母代理快速处理 | ⚠️ 仅使用母代理（可以省略工作代理）。 |
| **多文件项目** | ⚠️ 仅针对核心逻辑 | ✅ 必须使用 | ✅ 必须使用。 |
| **Rust/Godot等项目** | ✅ 必须使用 | ✅ 必须使用 | ✅ 必须使用。 |

## 子代理的启动示例：
**主代理（Master） → 母代理（Mother）：**
```
label: ralph-mother
task: "[요구사항 요약] 구현. specs/ 작성 → IMPLEMENTATION_PLAN.md → 워커로 구현 → 2단계 리뷰 → 완료 시 보고"
```
**母代理（Mother） → 工作代理（Worker）：**
```
label: ralph-worker-1
task: "태스크: [구체적 태스크]. 스펙: [전문 텍스트]. 구현 후 검증 실행, 증거 포함 결과 보고."
```

## 上下文管理：
- **主代理（Master）**：保持最小的上下文信息，专注于与用户的沟通。
- **母代理（Mother）**：仅跟踪整个项目的计划和进度。
- **工作代理（Worker）**：专注于单个任务（保持80-90%的专注度）。
- 🆕 **将详细的规范直接传递给工作代理**：避免因读取文件而增加开销（借鉴Superpowers的做法）。

## 详细指南：
有关更复杂项目的开发流程，请参考[references/workflow.md]。