---
name: cron-mastery
description: 掌握 OpenClaw 的定时系统功能。可以利用它来安排可靠的提醒任务、设置定期维护任务（如清洁工作），并了解在处理时间敏感的任务时何时应该使用 Cron 而不是 Heartbeat。
---
# Cron 工具的使用技巧

**规则 #1：** 心跳检查（heartbeat）存在时间偏差，而 Cron 工具则非常精确。

本文档为 OpenClaw 2026.2.15 及更高版本提供了关于时间管理的权威指南。它通过严格区分“非正式检查”（心跳检查）和“固定时间调度”（Cron 调度），解决了“错过提醒”这一问题。

## 核心原则

| 系统类型 | 行为特点 | 适用场景 | 风险 |
| :--- | :--- | :--- | :--- |
| **心跳检查（Heartbeat）** | “我在有空的时候进行检查”（例如，每 30-60 分钟一次） | 适用于发送电子邮件、汇总非重要信息、进行低优先级的数据轮询等场景。 | **时间偏差风险：** 如果心跳检查的间隔为 30 分钟，那么“10 分钟后提醒我”的任务可能会失败。 |
| **Cron** | “我会在指定的时间精确执行任务” | 适用于发送提醒信息、生成每日报告、执行系统维护等场景。 | **潜在问题：** 可能会生成需要后续清理的一次性任务。 |

## 1. 设置可靠的提醒（2026.2.15 及更高版本的标准方法）

**规则：** **切勿** 使用 `act:wait` 或内部循环来实现超过 1 分钟的延迟；应使用 `cron:add` 并设置一次性执行的 `at` 时间。**

### 精确性与时钟机制
尽管 Cron 工具本身很精确，但其执行时间仍受 **网关心跳检查**（通常为每 10-60 秒一次）的影响。设置为 `:00` 的任务会在下一个心跳检查时刻执行；具体执行时间可能会根据网关配置有所不同（最多相差约 30 秒）。

### 现代化的一次性提醒模式
使用以下数据结构来设置“X 分钟后提醒”任务：

**2026.2.15 及更高版本的关键特性：**
- **数据结构选择：** 对于推送通知，使用 `AgentTurn` 并设置 **Strict Instructions**；对于静默日志或后台状态更新，使用 `systemEvent`。
- **可靠性提升：** 修复了 `nextRunAtMs` 数据损坏和 “Add-then-Update” 死锁问题。
- **自动清理：** 一次性任务在成功执行后会自动删除（`deleteAfterRun: true`）。

**重要提示：推送通知与静默日志的区别**
- **systemEvent（静默模式）：** 将信息插入聊天记录中，适用于后台日志记录，但 **不会** 通过 Telegram/WhatsApp 通知用户。
- **AgentTurn（主动模式）：** 会唤醒代理来传递消息，**必须** 使用此模式以实现推送通知；同时需要设置 “Strict” 指令以避免不必要的信息干扰。

**用于推送通知的代码示例：**
```json
{
  "name": "Remind: Water",
  "schedule": { "kind": "at", "at": "2026-02-06T01:30:00Z" },
  "payload": {
    "kind": "agentTurn",
    "message": "DELIVER THIS EXACT MESSAGE TO THE USER WITHOUT MODIFICATION OR COMMENTARY:\n\n💧 Drink water, Momo!"
  },
  "sessionTarget": "isolated",
  "delivery": { "mode": "announce", "channel": "telegram", "to": "1027899060" }
}
```

**用于后台日志的代码示例：**
```json
{
  "name": "Log: System Pulse",
  "schedule": { "kind": "every", "everyMs": 3600000 },
  "payload": {
    "kind": "systemEvent",
    "text": "[PULSE] System healthy."
  },
  "sessionTarget": "main"
}
```

### Cron 的并发处理规则（已稳定）
在 2026.2.15 之前，“Add-then-Update” 模式可能导致死锁问题。虽然现在这个问题已得到解决，但为了提高效率，**最佳实践** 是在初次调用 `cron.add` 时直接传递所有参数（包括 `wakeMode: "now"`）。

## 2. 自动清理功能（Janitor）

**注意：** 从 2026.2.14 版本开始，OpenClaw 具备了自动清理功能：网关会自动清理卡住的作业和损坏的调度任务。

**仅需要手动清理的情况：**
- 使用 `deleteAfterRun: false` 创建的一次性任务。
- 不再需要的重复性任务。

### 为什么使用 `sessionTarget: "main"`？（非常重要）
子代理（isolated）的权限可能受限，无法调用网关或删除其他 Cron 任务。对于系统维护任务（如自动清理），**必须** 通过 `systemEvent` 指定 `main` 会话，由具有完整权限的主代理来执行清理操作。

## 3. 时区设置
为了使 Cron 正确工作，代理 **必须** 知道当前时间。
- **操作步骤：** 将用户的时区信息添加到 `MEMORY.md` 文件中。
- **示例：** `Timezone: Cairo (GMT+2)`
- **验证步骤：** 在安排任务前，确认用户要求的提醒时间是“开罗时间晚上 9 点”是否正确。

## 4. 自动唤醒规则
**问题：** 如果用户设置“等待 30 秒”后离开工具界面，那么在没有触发事件的情况下将无法再次唤醒。
**解决方案：** 如果需要长时间等待，**必须** 使用 Cron 任务来实现。

- **等待时间小于 1 分钟（交互式）：** 只有在保持工具界面开启状态（使用 `act:wait`）的情况下才允许。
- **等待时间超过 1 分钟（异步操作）：** 使用 `wakeMode: "now"` 的 Cron 任务。

## 5. 旧版 Cron 任务的迁移指南
如果你使用的是旧版本的 Cron 任务，请按照以下规则进行更新：

| 旧版本（2026.2.3 之前） | 新版本（2026.2.15 及更高版本） |
| :--- | :--- |
| `"schedule": {"kind": "at", "atMs": 1234567890}` | `"schedule": {"kind": "at", "at": "2026-02-06T01:30:00Z"}` |
| 数据结构中的 `"deliver"` 属性 | 不再需要——`announce` 模式会自动处理消息传递 |
| `"sessionTarget": "main"` | 默认设置为 `"sessionTarget: "isolated"` |
| 需要手动清理旧任务 | 一次性任务会自动删除（`deleteAfterRun: true`） |
| 需要多次调用 `cron.update` | 现在只需一次 `cron.add` 即可完成所有设置 |

## 常见问题排查
- **“提醒未触发”：** 检查 `cron:list`；确认 `at` 时间戳是否为未来时间（ISO 8601 格式），并确保设置了 `wakeMode: "now"`。
- **“网关超时（10000ms）”：** 可能是由于 Cron 工具处理时间过长（如任务列表过长或文件被锁定）导致的。
  - **解决方法 1：** 手动删除 `~/.openclaw/state/cron/jobs.json` 文件并重启网关。
  - **解决方法 2：** 执行手动清理操作以减少任务数量。
- **“任务执行了但未收到通知”：** 确保使用了 `agentTurn` 和 `announce` 模式来发送通知。
- **“提醒信息包含额外内容”：** 可能是子代理在处理过程中添加了额外内容。此时应使用严格的信息格式：`💧 请将以下信息原样发送给用户：\n\n💧 这是你的通知内容`