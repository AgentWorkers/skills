---
name: swift-architecture-skill
description: >
  **Swift架构设计与实现模式中的代理技能**  
  该技能涵盖了特定于架构的实践指南和审查清单，适用于新功能的设计、现有模块的重构、Pull请求的审核，以及SwiftUI/UIKit项目中可维护性问题的调试。在处理MVVM（Model-View-View Model）、MVI（Model-View-Instruction）、TCA（Test-Driven Architecture）、Clean Architecture、VIPER（Very Important Practical Extensions）或Reactive编程模式相关问题时，可提供具体的指导。
---
# Swift 架构技能

## 概述

使用此技能为 SwiftUI/UIKit 代码库选择最佳的 Swift 架构方案，并将其应用于用户的任务中。

## 工作流程

### 第 1 步：分析请求背景

在选择架构之前，需要收集以下信息：
- 任务类型（新功能、重构、代码审查、调试）
- UI 堆栈（SwiftUI、UIKit 或混合使用）
- 应用范围（单屏幕、多屏幕、全应用）
- 需要保留的现有编码规范

### 第 2 步：选择架构

如果用户明确指定了一个架构，请将其作为初始候选方案，并在提交前进行适配性检查：
- 根据 UI 堆栈（SwiftUI/UIK 或混合使用）、状态复杂性、效果协调需求、团队熟悉程度以及现有代码库规范来验证该架构的适用性；
- 如果适用，则采用该架构；
- 如果架构不符合关键要求，请明确说明不匹配的原因，并从 `references/selection-guide.md` 中推荐最接近的替代方案；
- 如果用户仍坚持使用不匹配的架构，请制定风险缓解计划，并提前说明相关风险。

如果没有指定架构，请加载 `references/selection-guide.md`，并根据所述约束（状态复杂性、团队熟悉程度、测试目标、效果协调需求和框架偏好）来推断最佳方案，并简要解释推荐理由。

**架构参考文档链接**：
- MVVM → `references/mvvm.md`
- MVI → `references/mvi.md`
- TCA → `references/tca.md`
- Clean Architecture → `references/clean-architecture.md`
- VIPER → `references/viper.md`
- Reactive → `references/reactive.md`

### 第 3 步：分析现有代码库（如适用）

如果已有代码存在，请执行以下操作：
- 识别当前的架构和依赖注入（DI）风格；
- 注意并发模型（async/await、Combine、GCD、混合使用）；
- 使推荐方案与本地编码规范保持一致。

### 第 4 步：生成具体交付物

阅读所选架构的参考文档，并将其指导内容转化为符合用户需求的交付物：

- **文件和模块结构**：包含特定于该功能的目录布局和文件名；
- **状态和依赖边界**：明确的状态类型、协议和依赖注入点；
- **异步策略**：取消操作、actor 隔离和错误处理方式；
- **测试策略**：需要测试的内容、如何模拟依赖项以及示例测试结构；
- **迁移路径**（针对重构）：从当前架构逐步迁移到目标架构的步骤；
- **UI 堆栈适配**：针对所选架构，说明 SwiftUI 和 UIKit 在哪些方面需要有所不同。

### 第 5 步：使用检查表进行验证

最后，使用参考文档中提供的特定于该架构的代码审查检查表，根据用户的具体需求进行调整。

## 输出要求：

- 确保推荐方案仅针对请求的功能或审查任务；
- 倡导基于协议的依赖注入和明确的状态建模；
- 指出现有代码中的反模式并提供直接的修复建议；
- 在所有异步流程中包含取消操作和错误处理机制；
- 对于明确指定的架构请求，提供简短的适配结果（“适用”或“不匹配”），并说明原因（1-2 个）；
- 对于不匹配的情况，提供最接近的替代方案及其为何更符合要求；
- 编写代码时，仅包含与任务相关的模式，避免复制整个架构方案；
- 默认情况下，将参考文档中的代码片段作为示例使用；只有在用户要求提供可运行代码时，才提供完整的编译环境；
- 仅提出最低限度的疑问；否则，请事先明确相关假设；
- 在审查代码提交（PR）时，使用特定于该架构的检查表，并针对具体问题指出错误并进行修复。