---
name: test-driven-development
description: 在实现任何功能或修复漏洞时使用，但在编写实际实现代码之前。
---

# 面向测试的开发（Test-Driven Development, TDD）

## 概述

首先编写测试用例，然后观察它们是否失败；接着编写最简短的代码来使这些测试通过。

**核心原则：** 如果你没有看到测试用例失败，你就无法确定它们是否真正测试了预期的功能。

**违反规则的形式，实际上也是在违反规则的精神。**

## 适用场景

**始终适用：**
- 新功能的开发
- 错误的修复
- 代码重构
- 行为的变更

**例外情况（请咨询你的团队成员）：**
- 临时性的原型代码
- 生成的代码
- 配置文件

“这次就跳过TDD吧？”——别这么做，这只是在为自己的行为找借口。

## 铁律

**如果在编写测试之前就先编写了代码，**请直接删除这些代码，并重新开始。

**没有任何例外：**
- 不要将其作为“参考”保留
- 在编写测试时不要对其进行“修改”
- 不要去看那些已经存在的代码
- 删除就意味着彻底删除

**必须严格按照“红-绿-重构”的流程来开发代码。**

### 红色阶段（RED）——编写失败的测试用例

编写一个最简短的测试用例，用来验证预期的功能是否能够正常工作。

**好的示例：**
```python
# test('validates email and domain and whitespace')
```
- 测试用例的名称应该清晰明了，且只针对一个具体的功能进行测试。

**错误的示例：**
```python
# test('someRandomFunction')
```
- 测试用例的名称应该具体明确，且应该测试真实的代码行为，而不是模拟代码。

**要求：**
- 只测试一个具体的功能
- 测试用例的名称应该清晰明了
- 使用真实的代码进行测试（除非确实有必要，否则不要使用模拟对象）

### 绿色阶段（GREEN）——编写最简短的代码来通过测试

编写最简短的代码来通过测试用例。

**好的示例：**
```python
# 最简短的代码实现
```
- 只编写足够通过测试的代码。

**错误的示例：**
```python
# 过度设计的代码实现
```
- 不要为新的功能添加代码，也不要对其他代码进行重构，更不要超出测试用例的范围去“改进”代码。

### 重构阶段（REFactor）——优化代码

**只有在代码通过测试之后，才可以进行重构：**
- 删除重复的代码
- 优化函数/方法的名称
- 提取出可重用的辅助函数

**重复上述流程，直到所有测试都通过。**

## 优秀的测试用例的特点

| 特点 | 优秀测试 | 不优秀的测试 |
|---------|---------|---------|
| **简洁性** | 只测试一个具体的功能 | 测试用例的名称包含多个不相关的功能 |
| **清晰性** | 测试用例的名称能够准确描述其测试的内容 | 测试用例的名称不明确 |
| **目的性** | 测试用例能够清楚地展示代码应该实现的功能 | 测试用例无法体现代码的实际用途 |

## 为什么测试的编写顺序很重要

**“我会在代码实现之后再编写测试用例来验证其正确性”**

如果在代码实现之后才编写测试用例，那么这些测试用例就无法立即证明代码的正确性：
- 可能会测试到错误的功能
- 可能只会测试到代码的实现细节，而无法验证实际的功能
- 可能会遗漏一些边缘情况
- 你可能永远无法发现某些错误

**先编写测试用例**可以确保你看到测试用例失败，从而确认它们确实能够正确地验证代码的功能。

**“我已经手动测试了所有的边缘情况”**

手动测试往往是随意的、非系统化的：
- 你无法记录自己测试了哪些内容
- 当代码发生变化时，无法重新运行测试
- 在压力下很容易忘记已经测试过的内容
- “我当时测试时它运行正常”并不意味着代码就完全没有问题

**自动化测试是系统化的**，每次运行都会执行相同的测试流程。

**“删除已经编写好的测试用例是浪费时间”**

这是一种“沉没成本谬误”——那些时间已经过去了。你现在可以选择：
- 删除这些代码，并使用TDD重新编写测试（虽然可能需要更多的时间，但能提高代码的可靠性）
- 保留那些代码，并在之后再编写测试（虽然效率较低，但风险也更高）

**“TDD过于僵化，实际开发中应该灵活应对”**

**TDD本身就是灵活的：**
- 它可以在提交代码之前发现错误（比事后调试更快）
- 防止代码退化（测试用例能立即发现错误）
- 文档化了代码的功能（测试用例说明了代码的使用方法）
- 便于代码重构（可以自由修改代码，而测试用例能确保修改后的代码仍然正常工作）

**“事后编写测试也能达到相同的目的”**

这种观点是错误的。事后编写测试只能验证代码的实现结果，而先编写测试用例才能确保代码符合预期的设计。

**事后编写测试**会受到代码实现的影响；你测试的是自己已经编写好的代码，而不是代码应该实现的功能。而先编写测试用例则能确保你确实实现了预期的功能，并且能发现那些被遗忘的边缘情况。

**事后编写测试可能需要30分钟，但TDD能带来更高的效率**：通过TDD，你不仅能获得代码的覆盖率，还能确保代码的正确性。

## 常见的借口与现实

| 常见借口 | 实际情况 |
|--------|---------|
| “代码太简单，不需要测试” | 即使代码很简单，也可能出错；测试只需要30秒而已。 |
| “我会在之后再测试” | 事后编写的测试无法立即证明代码的正确性。 |
| “事后编写测试也能达到相同的目的” | 事后编写测试只能验证代码的实现，而先编写测试用例才能确保代码符合设计要求。 |
| “我已经手动测试过了” | 手动测试是非系统化的；没有记录，也无法重新运行。 |
| “删除已经编写好的测试用例是浪费时间” | 保留未经验证的代码实际上是一种技术上的负担。 |
| “先保留代码作为参考，之后再编写测试” | 你可能会修改这些代码；但这样做其实是在事后编写测试。删除代码才是正确的做法。 |
| “需要先探索代码的功能” | 没关系，可以先使用TDD来探索代码。 |
| “如果测试太难，说明设计有问题” | 如果测试难以编写，说明代码的设计本身就有问题。 |
| “TDD会拖慢开发速度” | 实际上，TDD的效率更高。 |
| “手动测试更快” | 手动测试无法覆盖所有的边缘情况；每次修改都需要重新测试。 |
| “现有的代码没有测试用例” | 你正在改进这些代码，所以应该为它们添加测试用例。 |

## 需要立即停止并重新开始的信号

- 在编写测试之前就先编写了代码
- 在代码实现之后才编写测试用例
- 测试用例通过后立即就通过了
- 无法解释测试失败的原因
- 后来才添加的测试用例
- 以“这次就跳过TDD”为借口
- “我已经手动测试过了”
- 认为“事后编写测试和先编写测试的目的相同”
- 认为“TDD只是形式主义”

**遇到以上任何情况，都应该立即删除现有的代码，并重新开始使用TDD。**

## 示例：修复错误**

**错误示例：** 程序接受空电子邮件地址

**红色阶段（RED）——编写测试用例：**
```python
# test('email_is_empty')
```

**验证测试用例是否通过：**
```python
# 测试用例是否能够正确地检测到空电子邮件地址**
```

**绿色阶段（GREEN）——编写代码实现：**
```python
# 实现验证电子邮件地址是否为空的逻辑**
```

**重构阶段（REFactor）——根据需要，提取出用于验证多个字段的通用逻辑。**

## 验证完成后的检查清单

在确认工作完成之前，请确保满足以下条件：
- 每个新添加的函数/方法都有对应的测试用例
- 在实现代码之前，确保每个测试用例都能正确地失败（即测试用例能够检测到预期的错误）
- 每个测试用例都使用了最简短的代码来通过
- 所有的测试用例都能通过
- 测试的输出结果正常（没有错误或警告）
- 测试用例使用的是真实的代码（只有在必要时才使用模拟对象）
- 所有的边缘情况和错误都能被覆盖

如果无法满足所有条件，说明你没有按照TDD的流程来编写测试用例，需要重新开始。

## 遇到困难时的解决方法

| 遇到的问题 | 解决方法 |
|---------|---------|
| 不知道如何编写测试用例 | 先设计出你希望测试的功能接口，然后再编写测试用例；如果需要，可以咨询团队成员的帮助。 |
| 测试用例太复杂 | 说明代码的设计过于复杂；简化接口。 |
| 必须使用模拟对象 | 说明代码的耦合度过高；使用依赖注入来解耦代码。 |
| 测试设置过于繁琐 | 提取出可重用的辅助函数；如果仍然复杂，再简化代码的设计。 |

## 调试集成代码中的错误

发现错误后，首先编写一个能够重现该错误的测试用例，然后按照TDD的流程进行测试。测试用例不仅能验证修复后的代码是否正确，还能防止代码出现退化。

**注意事项：** 在修复错误时，一定要先编写相应的测试用例。

## 避免常见的测试误区

在编写测试用例或使用测试辅助工具时，请参考 @testing-anti-patterns.md 来避免常见的错误：
- 只测试模拟对象的行为，而不是实际的功能
- 在生产代码中添加仅用于测试的辅助方法
- 在不了解代码依赖关系的情况下使用模拟对象

## 最后的规则

**在没有团队成员的许可下，**任何情况下都不得违反TDD的原则。