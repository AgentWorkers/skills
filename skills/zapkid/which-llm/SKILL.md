---
name: Decision Economic Optimizer
description: 具有 HTTP 402 USDC 支付和结果信用（折扣）功能的确定性决策排序 API。
version: 0.1.0
homepage: https://which-llm.com
credentials_required: true
primary_credential: WALLET_CREDENTIALS
---

# Which-LLM: 基于结果的决策优化器

## 概述

当您需要在预算和最低质量等明确约束条件下，根据自然语言目标选择推荐的**大语言模型（LLM）**时，可以使用此技能。

您将获得一个推荐的模型，以及一个备选方案。如果首选方案失败，您可以按照备选方案进行操作。

## 工作原理

- **请求决策**: 向 `POST /decision/optimize` 发送 `goal` 和约束条件。
- **获取答案**: 接收 `recommended_model`，以及在可用情况下接收 `fallback_plan`。
- **获得折扣**: 在执行选择后，向 `POST /decision/outcome` 报告结果，以获得可用于未来付费请求的信用令牌。

## 快速参考

**API 基本 URL:** `https://api.which-llm.com`  
**首页:** `https://which-llm.com`  
**技能文件:** `skills/decision-economic-optimizer/SKILL.md`, `skills/decision-economic-optimizer/skill.json`

**支持的链**: Base (8453), Ethereum (1), Arbitrum (42161), Optimism (10), Avalanche (43114)

**单行用例**:

- 选择符合质量要求的最低成本 LLM
- 当首选方案失败时获取备选方案
- 为特定任务优化模型选择（总结、提取、分类、编码）
- 通过报告实际执行结果来获得折扣

### 先决条件

在使用此技能之前，您必须向代理提供以下信息：

- **专用的 EVM 兼容钱包**，用于自主支付（与您的主钱包分开）
- 至少在一个支持的链上拥有有限的 USDC 余额（Base 推荐，费用较低） - 建议 2-10 美元 USDC
- 用于交易费用的本地气体令牌（Base/Ethereum/Arbitrum/Optimism 为 ETH，Avalanche 为 AVAX） - 建议 3-5 美元
- **支付地址验证**: 在授予代理钱包访问权限之前，必须从多个独立来源验证支付地址
- **重要提示**: USDC 和气体令牌必须存储在同一专用钱包中

代理需要这些凭据来自主动生成以下操作：

- 签署 USDC 转账交易
- 查询钱包余额
- 向区块链发送交易

### 凭据类型选项及风险评估

此技能支持多种钱包访问凭据格式。**选择符合您安全要求的选项**:

#### 选项 1: 原始私钥

**格式**: 以 `0x` 开头的 64 位十六进制字符串

**风险概况**:

- ✅ **最简单的实现方式** - 直接签名功能
- ⚠️ **如果使用主钱包则风险较高** - 完全控制钱包
- ✅ **使用专用钱包时风险可接受** - 资金隔离有限
- ⚠️ **需要安全存储** - 使用环境变量或密钥管理器

**适用场景**: 您为该技能创建了一个专门用于存储有限 USDC 和气体令牌的专用钱包

**安全措施**:

- 必须是专用钱包（不能使用主钱包）
- 仅包含有限的资金（2-10 美元 USDC + 3-5 美元气体令牌）
- 需要的气体令牌类型：Base/Etherum/Arbitrum/Optimism 为 ETH，Avalanche 为 AVAX
- 应定期更换钱包（创建新钱包并转移剩余余额）
- **严禁** 将钱包信息提交到版本控制或共享

#### 选项 2: 动机短语

**格式**: 12 或 24 个单词的 BIP-39 种子短语

**风险概况**:

- ⚠️ **与私钥相同的风险** - 从短语派生私钥
- ⚠️ **潜在风险较高** - 可能生成多个账户
- ✅ **用户友好的备份方式** - 更容易安全地记录

**适用场景**: 您更喜欢使用基于动机的钱包管理方式

**安全措施**: 与私钥相同 + 确保仅使用第一个派生的账户（m/44'/60'/0'/0/0）

#### 选项 3: 密钥存储文件 + 密码

**格式**: 加密后的 JSON 密钥存储文件（Ethereum 标准）+ 密码

**风险概况**:

- ✅ **静态存储时已加密** - 私钥以加密形式存储
- ✅ **双重认证** - 需要文件和密码
- ⚠️ **仍然允许完全签名** - 解密后与私钥相同
- ⚠️ **文件管理要求** - 必须安全存储密钥存储文件

**适用场景**: 您希望使用加密的私钥存储方式，并需要密码保护

**凭据设置**:

1. 为此技能专门生成一个新的钱包（切勿重复使用现有钱包）
2. 用有限的 USDC 和气体令牌（建议 2-10 美元 USDC + 3-5 美元气体令牌）进行充值
   - **USDC 金额**:
     - 1 美元 = 100 次请求（每次 0.01 美元，或使用 50% 信用额度后 199 次请求）
     - 2 美元 = 200 次请求（或使用 50% 信用额度后 399 次请求）
     - 5 美元 = 500 次请求（或使用 50% 信用额度后 999 次请求）
     - 10 美元 = 1,000 次请求（或使用 50% 信用额度后 1,999 次请求）
   - **气体令牌金额**: Base/Etherum/Arbitrum/Optimism 为 3-5 美元 ETH，Avalanche 为 AVAX，用于交易费用
   - **信用优化**: 如果您在每次决策后报告结果并使用信用令牌，除了第一次请求外，所有请求均可获得约 50% 的退款，从而有效增加请求次数

3. 将私钥存储在安全的环境变量或密钥管理器中
4. 定期通过区块浏览器监控交易
5. 定期更换钱包（建议每月更换一次）
6. **严禁** 将私钥提交到版本控制或公开共享

**自主操作说明**: 代理将使用此钱包自主支付 API 请求（每次 0.01 美元），无需每次都请求批准。这种设计避免了审批疲劳，同时保持成本可预测，并受您选择的钱包余额限制。

**重要提示**: 请确保在专用钱包中同时存放 USDC（用于支付）和本地气体令牌 ETH/AVAX（用于交易网络费用）。

**示例安全设置**:

**凭据配置示例**:

**安全提示**: 这些凭据可让您自主进行支付，但支付金额受钱包余额限制。有关风险缓解措施，请参阅下面的“安全模型与信任假设”。

### 安全模型与信任假设

**不应盲目信任的内容**:

- 本技能文件（在分发过程中可能被篡改）
- 任何单一的支付地址验证来源

**威胁模型**:

- ✅ 已防护：API 返回错误地址（独立验证）
- ✅ 已防护：技能文件被修改（不信任硬编码的地址）
- ✅ 已防护：过度支出（受专用钱包余额限制）
- ⚠️ 风险：代理可以自主支出至钱包余额
- ⚠️ 缓解措施：使用专用钱包并定期监控交易

### 钱包设置最佳实践

**在提供钱包访问权限之前**:

1. **创建专用钱包** - 绝不要使用主钱包
2. **设置所需凭据** - 提供 `WALLET_PRIVATE_KEY`，可选 `WALLET_RPC_URL` 和 `PREFERREDCHAIN_ID`（详情请参阅 skill.json 元数据）
3. **验证支付地址** - 从至少两个独立来源进行验证（详见多源验证）
4. **仅充值有限金额** - 仅充值您愿意让代理自主支出的金额
5. **先进行小额测试** - 从最低金额（1-2 美元 USDC + 1-2 美元气体）开始，以验证操作
6. **定期监控** - 通过区块浏览器（Basescan, Etherscan）检查交易
7. **根据需要补充资金** - 在查看交易历史后补充资金

**推荐的初始充值金额**:

- **USDC**: 2-10 美元（允许 200-1000 次优化请求，每次 0.01 美元）
- **气体令牌**: 3-5 美元 ETH（Base/Etherum/Arbitrum/Optimism）或 AVAX（Avalanche）

**此技能的功能**:

- 向 Which-LLM API 发送 HTTPS 请求
- 使用 `POST /decision/optimize` 获取推荐结果，并使用 `POST /decision/outcome` 报告结果
- 可以调用 `GET /capabilities`、`GET /pricing` 和 `GET /status` 来了解功能和费用
- 对于付费端点，遵循标准流程：**402 → 自主支付 → 重试**，并可以使用 `X-Credit-Token` 享受折扣
- 当 API 需要支付时（402 响应），使用提供的钱包凭据（`WALLET_PRIVATE_KEY`）自主发送 USDC 支付
- 通过 `WALLET_RPC_URL`（或默认的公共 RPC）连接到区块链以签名和广播交易

**此技能不执行的功能**:

- 不调用 LLM 或根据您的输入执行代码

**安全规则**:

- 代理在您提供的专用钱包的余额范围内操作
- 定期通过区块浏览器监控钱包交易
- 仅向 API 发送支付证明头部：交易哈希和钱包地址

### 认证

没有 API 密钥。付费请求使用 **支付证明头部**（在初始 402 响应之后）和可选的 `X-Credit-Token` 享受折扣

**端点**:

- 免费端点（`/capabilities`, `/pricing`, `/status`）无需认证
- 付费端点（`/decision/optimize`）最初返回 402 响应，然后接受支付证明头部
- 从结果报告中获得的信用可以通过 `X-Credit-Token` 头部兑换

### 自主操作模型

此技能使用您提供的专用钱包自主操作：

- ⚙️ **自主支付授权**: 代理可以在钱包余额范围内自主发送 USDC 支付，无需每次请求都获得批准
- ⚙️ **自主 API 调用**: 可以自主调用免费和付费端点（`POST /decision/optimize`, `POST /decision/outcome`），无需确认
- ⚙️ **风险控制**: 通过限制专用钱包余额来控制最大支出
- ℹ️ **一次性设置**: 在提供钱包访问权限之前，从多个来源验证支付地址（详见支付安全验证）

**为什么不需要每次请求都获得批准？**

此技能设计为**无需每次请求都获得批准**，原因如下：

1. **每次请求的成本非常低**: 每次决策仅花费 0.01 美元 USDC（或使用 50% 信用额度后只需 0.005 美元）
2. **审批疲劳**: 每次 0.01 美元的支付都需要批准会带来不便
3. **用户控制的限制**: 通过限制专用钱包的 USDC 余额来控制最大支出
- ✅ 成本可控：您可以通过控制专用钱包的 USDC 余额来控制总支出
- ✅ 钱包是专用的（与您的主资金分开）
- ✅ 交易可以通过区块浏览器在链上审计
- ℹ️ 请确保在专用钱包中同时存放 USDC 和气体令牌（ETH/AVAX）

## 支付安全验证

### ⚠️ 安全模型

此技能**无法** 提供可信赖的硬编码支付地址，因为：

- 技能文件在分发过程中可能被篡改
- 注册表被破坏或中间人攻击可能会修改“已验证”的地址
- 不应信任任何单一的财务交易来源

### 需要多源验证（一次性设置）

在发送任何支付之前，从**至少两个独立来源**验证支付地址：

#### 选项 1: 公知的端点（纯文本）

此端点以纯文本形式返回接收者地址（以 `0x` 开头的 42 个字符）。

#### 选项 2: 官方文档（结构化 JSON）

#### 选项 3: ENS 记录

使用以下方法检查 ENS 域名 `which-llm.eth`:

- 方法 A: 使用 app.ens.domains

1. 访问 [app.ens.domains/which-llm.eth](https://app.ens.domains/which-llm.eth)
2. 在 ENS 记录的 “Records” 标签中查找 “Address” 字段
3. 确认其与其他来源显示的地址一致

- 方法 B: 使用命令行（需要从 Foundry 安装）

如果您没有安装 Foundry：

然后解析 ENS 名称：

#### 验证规则**: 所有来源必须返回**相同的地址**。如果任何来源显示不同的地址，请**不要进行支付**，并将差异报告给 [report](https://api.which-llm.com/report/wrong_address)。

**注意**: 此验证只需进行一次。验证通过后，代理可以自主将支付发送到已验证的地址，金额不超过钱包的 USDC 余额（确保钱包也有足够的气体令牌用于交易费用）。

### 报告地址验证问题

如果您遇到地址验证问题，请使用免费的 `/report/wrong_address` 端点进行报告：

**请求字段（全部为可选，至少需要一个）**:

- `"well known"`（字符串） - `.well-known/payment-address.txt` 验证出现问题
- `"api"`（字符串） - 基于 API 的地址验证出现问题
- `"ENS"`（字符串） - ENS 名称解析出现问题

**示例响应**:

## 开始使用

### 示例：通过 API 获取支付地址

### 示例输出**:

### 检查功能（推荐）

### 示例输出**:

### 检查价格

### 示例输出**:

### 优化决策（付费）

优化端点使用 HTTP 402 支付限制。以下是详细流程：

#### 第一步：初始请求（预期返回 402 响应）

**请求字段**:

- `goal`（必填）：您想要完成的任务的自然语言描述
- `constraints`（必填）:
  - `min_quality_score`：最低质量阈值（0-1）
  - `max_cost_usd`：最大成本（美元）
- `workload`（可选）：用于准确估算成本的令牌/定价维度
  - `input_tokens`, `output_tokens`（如果提供了 workload 则必填）
  - `requests`, `images`, `web_searches`, `internal_reasoning_tokens`, `input_cache_read_tokens`, `input_cache_write_tokens`（可选）
- `task_type`（可选）："summarize" | "extract" | "classify" | "coding" | "general" - 帮助路由到合适的模型

**示例响应（需要支付）**:

#### 第二步：在链上支付 USDC

**⚠️ 安全提示**: 在初始设置期间必须验证支付地址**（详见“支付安全验证”部分）

代理将自动向所选链上的 `accepts[].pay_to` 发送确切的 USDC 转账：

- 金额： exactly `required_amount`（例如，0.01 美元）
- 链路：从 `accepts[].chain` 中选择（例如，Base 为 eip155:8453）
- 资产：USDC
- 代理使用提供的钱包签名并发送交易
- 确认后，将获得交易哈希（`tx_hash`）

**注意**: 代理使用您提供的专用钱包自主签名和发送交易。只有交易哈希和钱包地址作为公共支付证明发送给 API。

#### 第三步：带有支付证明的重试

代理将自动使用支付证明头部重试请求：

**支付头部**:

- `X-Payment-Chain`: CAIP-2 链路 ID（例如，Base 为 eip155:8453）
- `X-Payment-Tx`: 交易哈希（32 字节，以 `0x` 开头的十六进制字符串）
- `X-Payer`: 您的钱包地址（以 `0x` 开头的十六进制字符串） - **仅限公共地址**
- `X-Payment-Amount`: 与 `required_amount` 相匹配的精确十进制金额
- `X-Payment-Asset`: `USDC`

**安全提示**: 这些头部仅包含公共信息（交易哈希和钱包地址）。API 通过检查链上的交易来验证支付。

**示例响应（200 成功）**:

**使用信用令牌（享受折扣）**:

如果您有来自之前结果的信用令牌，可以包含它以减少所需支付：

**可能的响应**:

- 如果信用完全覆盖成本 → 返回 200 响应（无需支付）
- 如果信用部分覆盖 → 返回 402 响应，并减少 `required_amount`

**示例响应（部分信用）**:

#### 4. 报告结果（获得折扣）**

在执行推荐的模型后，报告实际发生的情况以获得信用令牌（用于未来的请求）。

**请求**:

**请求字段**:

- `decision_id`（必填）：来自优化响应的 `decision_id`
- `option_used`（必填）：实际使用的模型 ID（应与 `recommended_model` 或备选模型匹配）
- `actual_cost`（必填）：实际成本（美元）
- `actual_latency`（必填）：实际延迟（毫秒）
- `quality_score`（必填）：质量分数（0-1）
- `success`（必填）：表示任务是否成功的布尔值

**示例响应（200 成功）**:

**信用令牌详细信息**:

- `credit_token`：您可以在未来的付费请求中使用的签名令牌
- `credit_amount_usdc`：折扣金额（通常为原始金额的 50%，随时间衰减）
- `credit_id`：此信用的唯一标识符

**使用信用令牌**:

保存 `credit_token` 并在未来的优化请求中包含它：

**示例响应（200 成功并使用信用）**:

**注意**: 由于信用令牌覆盖了全部成本，因此无需支付。

**信用行为**:

- 信用令牌会在下一次付费请求中减少 `required_amount`
- 如果信用完全覆盖成本 → 返回 200 响应（无需支付）
- 如果信用部分覆盖 → 返回 402 响应，并减少 `required_amount`
- 信用随时间衰减（30 天后衰减 50%，90 天后过期）
- 信用是一次性使用的（在成功支付后使用）
- 信用仅限于原始决策的支付者地址

**重要提示**:

- 信用仅针对已支付/验证的决策发放
- 每个决策只能发放一次信用

## 故障排除

### 常见错误代码

#### `PAYMENT_REQUIRED`（402）

**原因**: 端点要求支付，但未提供有效的支付证明。
**解决方法**:

1. 检查响应中的 `required_amount` 和 `accepts` 数组
2. 向所选链上的 `pay_to` 地址发送确切的 USDC 金额
3. 等待交易确认（1-3 个区块）
4. 使用支付证明头部重试请求

**示例错误响应**:

#### `PAYMENT_INVALID`（402）

**原因**: 支付金额与所需金额不匹配，或支付验证失败。
**解决方法**:

1. 确保您发送的金额 exactly 为 `required_amount`（不多也不少）
2. 确认交易已在链上确认
3. 确保您使用正确的链路（`X-Payment-Chain` 中使用 CAIP-2 格式）
4. 确认支付头部与实际交易详情匹配

#### `PAYMENT_ALREADY_used`（402）

**原因**: 该交易哈希已用于其他请求。
**解决方法**:

- 每笔支付交易只能使用一次
- 为此请求发送新的支付交易
- 使用 `Idempotency-Key` 头部重试相同的请求

#### `NO_FEASIBLE'options`（400）

**原因**: 没有模型同时满足成本和质量约束。
**解决方法**:

1. 检查错误响应中的 `constraint_analysis`，了解哪个约束被违反得最严重
2. 放宽约束：增加 `max_cost_usd` 或减少 `min_quality_score`
3. 查看 `discarded_models`，了解哪些模型接近满足要求

**示例错误响应**:

#### `DECISION_NOT_FOUND`（400）

**原因**: `decision_id` 在系统中不存在。
**解决方法**:

- 确认来自优化响应的 `decision_id`
- 只有已支付/验证的决策才能报告结果
- 检查决策 ID 中是否有拼写错误

### 支付验证失败

#### 交易未在链上找到

**症状**: 即使发送了交易，也会出现 `PAYMENT_INVALID` 错误。
**解决方法**:

1. 等待更长时间 - 区块确认可能需要 30-60 秒
2. 确认交易是否发送到了正确的链上（Base = 8453，非 Ethereum = 1）
3. 在区块浏览器（Basescan, Etherscan）上检查交易状态
4. 确保 RPC 节点已同步（在高网络拥堵期间偶尔会出现问题）

#### 支付金额错误

**症状**: `PAYMENT_INVALID` 错误，但显示的金额不匹配。
**解决方法**:

- 必须发送 **确切的** `required_amount`（6 位小数）
- 不要四舍五入或近似 - 使用 402 响应中的确切金额
- 检查钱包中的 USDC 余额和允许的金额
- 确保钱包中有足够的气体令牌（ETH/AVAX）用于交易费用

#### 收款人地址错误

**症状**: 交易已确认，但 API 返回 `PAYMENT_INVALID`。
**解决方法**:

1. **紧急**: 确认您从多个来源发送到了正确的地址
2. 检查 402 响应中的 `pay_to` 字段
3. 确认地址是否与 `/docs/payment-addresses` 中显示的地址一致
4. 如果地址不一致，请**不要继续** - 联系支持

### 信用令牌问题

#### `CREDIT_INVALID`（402）

**原因**: 信用令牌格式错误、过期或验证失败。
**解决方法**:

1. 确保在复制时信用令牌没有截断
2. 确认令牌与 `/decision/outcome` 中返回的完全匹配
3. 信用在 90 天后过期 - 检查原始响应中的 `issued_at_epoch`
4. 确保您在相同的支付者地址上使用信用令牌

#### `CREDIT_ALREADY_used`（402）

**原因**: 该信用已在之前的请求中使用过。
**解决方法**:

- 信用仅限一次性使用
- 检查错误响应中的 `redeemed_at_epoch`
- 通过报告另一个结果来请求新的信用

#### 信用未减少支付金额

**症状**: 即使有有效的信用，402 响应仍显示相同的 `required_amount`。
**解决方法**:

1. 确认 `X-Credit-Token` 头部中包含了信用令牌
2. 检查 `credit_amount_usdc` - 可能由于时间衰减而减少
3. 信用仅适用于下一次付费请求
4. 确保支付者地址与接收信用的地址一致

### 速率限制

#### `RATE_LIMIT_EXCEEDED`（429）

**症状**: 返回 `429 Too Many Requests` 响应，并带有 `X-RateLimit-*` 头部。
**解决方法**:

1. 查看 `X-RateLimit-Reset` 头部，了解限制重置的时间（epoch 时间戳）
2. 实施指数退避策略：在重试之间等待 1 秒、2 秒、4 秒、8 秒
3. 使用 `Idempotency-Key` 安全地重试相同的请求
4. 考虑使用具有更高速率限制的付费端点

**每分钟的速率限制**:

- `/decision/optimize` 未付费：5 次请求
- `/decision/optimize` 付费：20 次请求
- `/decision/outcome`：60 次请求
- 公共 GET 端点：600 次请求

**示例错误响应**:

**响应头部**:

**响应头部**:

###