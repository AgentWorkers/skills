---
name: subagent-driven-development
description: **使用说明：**  
在当前会话中执行包含独立任务的实施计划时，请使用此方法。
---

# 基于子代理的开发模式（Subagent-Driven Development）

该模式通过为每个任务分配一个新的子代理来执行计划，并在每个任务完成后进行两阶段审核：首先是规范合规性审核，其次是代码质量审核。

**核心原则：**  
为每个任务分配新的子代理 + 两阶段审核（先规范审核再代码质量审核） = 高质量、快速迭代

## 适用场景  
（此处可添加具体使用场景的描述）

**与“并行执行计划”模式的对比：**  
- **并行执行计划模式：**  
  - 在同一会话中执行所有任务（导致上下文切换）  
  - 每个任务使用相同的子代理（可能造成上下文混乱）  
  - 每个任务完成后仅进行一次审核  
  - 迭代速度较慢（任务之间需要人工干预）  

## 具体流程  
（此处可添加详细的执行流程）

## 提示模板：  
- `./implementer-prompt.md`：用于调度实现子代理  
- `./spec-reviewer-prompt.md`：用于调度规范合规性审核子代理  
- `./code-quality-reviewer-prompt.md`：用于调度代码质量审核子代理  

## 示例工作流程  
（此处可添加示例工作流程的描述）

## 相比手动执行的优点：  
- 子代理自然遵循测试驱动开发（Test-Driven Development, TDD）的原则  
- 每个任务都有清晰的上下文信息（避免混淆）  
- 支持并行执行（子代理之间不会相互干扰）  
- 子代理可以在工作前或工作过程中提出问题  

**相较于手动执行的额外优势：**  
- 自动化审核流程（无需人工干预）  
- 进度更透明（无需等待审核结果）  
- 提高效率：控制器会自动提供所需的所有上下文信息  
- 子代理在开始工作前就能获取完整的信息  

**质量保障措施：**  
- 自我审核机制能提前发现潜在问题  
- 两阶段审核确保问题得到妥善解决  
- 规范合规性审核防止过度或不足的开发  
- 代码质量审核确保实现逻辑的正确性  

**成本考虑：**  
- 需要更多子代理（每个任务需要一个实现子代理和两个审核子代理）  
- 控制器需要预先准备更多工作（提取所有任务信息）  
- 审核流程会增加迭代次数  
- 但能更早发现问题（比后期调试更经济）  

## 注意事项：  
- **严禁：**  
  - 未经用户明确同意，切勿在主分支（main/master branch）上开始开发  
  - 忽略任何阶段的审核  
  - 在问题未解决的情况下继续执行任务  
  - 并行调度多个实现子代理（可能导致冲突）  
  - 让子代理直接阅读计划文件（应提供完整的上下文信息）  
  - 忽略子代理的提问  
  - 对规范合规性的审核结果敷衍了事（即使审核员发现了问题，也需要重新审核）  
  - 在规范合规性审核未通过前就开始代码质量审核  
  - 在任何审核阶段仍有未解决的问题时，切勿进入下一个任务  

**子代理使用指南：**  
- 如果子代理提出问题，应清晰、完整地回答，并在必要时提供额外信息；  
- 不要催促子代理立即开始实施。  

**问题处理流程：**  
- 如果审核员发现问题，由同一子代理负责修复问题；  
- 审核员需重新审核问题；  
- 重复上述流程直至问题得到解决。  

**集成要求：**  
- 必须具备以下技能：  
  - `using-git-worktrees`：在开始之前需设置隔离的工作环境  
  - `writing-plans`：能够创建执行计划  
  - `requesting-code-review`：为审核子代理提供代码审核模板  
  - `finishing-a-development-branch`：在所有任务完成后完成开发流程  

**子代理应遵循的开发方法：**  
- 使用 `test-driven-development`（测试驱动开发）方法来执行每个任务。  

**替代工作流程：**  
- 可以选择 `executing-plans`（并行执行模式），但需注意避免上下文混乱。